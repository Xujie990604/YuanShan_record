# 项目中的静态资源使用

## public 和 assets 的区别

- Vue 在打包之后，会将一些业务级的 js 文件合并到一个 js 文件夹中去。再开发时我们可能会使用一些第三方的插件(比如 layer.js 弹窗文件)。这些第三方我们我们不愿意在打包时被压缩到业务级的 js 文件中。那么就需要一个静态的，非改变的目录来存放这些第三方插件。(这些文件可以在 index.html 文件中通过相对路径引入,因为打包后(public 文件不受影响)资源和 index.html 的相对路径并不会变化)
- public 文件夹中的内容在打包的时候，会被原封不动的移动到 dist 目录中
- assets 文件夹在打包时，会被 webpack 处理，合并到 js 业务代码中。(所以不可以在 index.html 文件中通过相对路径来引入 assets 文件夹中的资源，打包过后资源和 index.html 的相对位置会发生变化)(index.html 中的相对路径不会被 webpack 处理)

## Vue 请求静态资源中的路径

- URL 中是绝对路径，URL 会被直接保存下来(适合请求 public 文件夹中的内容)(注意此时的路径应该是基于打包后的路径)
- URL 中是相对路径。URL 中的内容会被作为一个模块进行请求。且基于你的文件系统中的目录结构进行解析。(适合请求 assets 文件夹中的内容)
- URL 开头是 ~ 其后任何内容都会被当做模块解析(可以加载含有别名的静态资源，又能够加载 node-modules 中的资源) `<img src="assets/img/home/recommend_bg.jpg" alt="">` 如果不加~符号的话，无法判断这是想用别名还是绝对路径，Vue 不知道是否需要使用 require() 来处理这个路径
- @ 是 Vue Cli 内置的一个 src 目录的别名

### Vue-loader

- require 是属于 node 的语法，是用来导入模块信息的。但是在 Vue 项目的 template 和 style 中我们没有使用 require 导入 通过相对路径的方式直接使用其他模块的静态资源。这是因为 Vue-loader 自动帮我们做了一次导入。
- template 中使用 别名需要在前面加上 ~。 style 中使用别名也要在前面加上 ~ 符号

## axios 中只能使用绝对路径

在 Vue 中使用 axios 或者 fetch 请求本地 JSON 数据或者图片等资源时，一定要放在 public 文件夹中(assets 中不可以)，并使用绝对路径引入(打包前和打包后的对应关系是 Vue 实现的。在 axios 中写相对路径又不会有功能工具去解析，真正代码的执行是在浏览器中执行的，要是 axios 中的路径是一个基于打包前文件目录的相对路径，当然会找不到)
要是使用相对路径请求的方式，由于浏览器识别的是 dist 文件，也就是打包后的文件，会导致找不到数据。

## require 中只能使用相对路径(只是在 Vue 中必须使用相对路径，在webpack 项目中不受限制)

在 Vue 中使用 require 来请求本地的 JSON 数据时，放在 public 和 assets 下都可以，但是必须使用相对路径的形式来导入 (使用绝对路径的方式来导入会找不到文件)(因为在执行 require 语句时 dist 文件夹还没生成，当然不能用绝对路径)
这种方式的请求是一种模块资源的请求(且为同步规范)，不会在浏览器的 network 模块中展示，如果请求的是图片，得到的会是一个经过 Vue 处理过的字符串路径。如果请求的是 json 会得到数据

## Vue 请求静态资源 (在 img 的 src 和 background 的 url 等场景下 )

- URL 中是绝对路径，URL 会被直接保存下来(适合请求 public 文件夹中的内容)(！！！此时的文件路径是基于打包后的文件路径)
- URL 中是相对路径。URL 中的内容会被作为一个模块进行请求(可以请求 assets 文件夹和 public 文件夹中的内容)(!!!此时的文件路径是基于当前的目录结构进行解析(当前的目录结构就是编辑器打开的文件夹))

有一个大胆的猜想。为什么两处的文件路径是基于不同的文件路径，是因为两种情况下，代码执行的时间不同。

1. 当 URL 是绝对路径时,在 Vue 解析 .vue 文件时根据就不会理会这个路径，直接就原封不动的写到 img 的 src 属性中。不会去判断这个路径下是否有正确的资源(也没有办法判断，因为现在代码还没热更新，dist 文件夹还没生成)。只有当这个 img 被浏览器进行识别的时候，才会去读 src 中的资源是否正确(此时的文件结构就已经是基于 dist 文件夹的结构了)

2. URL 是相对路径时，在 Vue 解析 .vue 文件时，就会基于当前的文件系统来读取一下是否有正确的资源。如果有资源的话会自动调用一次 require 来获取到资源。Vue 会计算出这个资源在打包之后的文件路径，然后将这个新的路径放到 img 的 src 中(当浏览器识别这个 img 时，会读取这个新的路径)

```js
// 这种形式的话，最终浏览器会去 http://localhost:8080/assets/img/home/recommend_bg.jpg 找资源
// 结果理所当然的是失败，因为打包过后 assets 文件夹早就不在了
// 正常情况下，src 中填写一个相对路径是会被 require 处理的。但是现在 src 搭配了 v-bind 修饰符，就不会调用 require 了。
<img :src="imageUrl" />
// 使用变量来接受一个相对路径的字符串
imageUrl: '../assets/img/home/recommend_bg.jpg'
```

```js
// 这种形式的话，最终浏览器会去 http://localhost:8080/img/aaa.jpg 找资源
// 结果是成功，因为 public 中的东西在打包后也会原封不动
// img 的 src 是一个变量
<img :src="imageUrl" />
// 使用变量来接受一个绝对路径的字符串
imageUrl: 'img/aaa.jpg'

// 这种做法的好处是什么，可以直接通过改变 imageUrl 变量的方式，来实现图片的切换
```
