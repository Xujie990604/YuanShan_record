# 优化

## Vue 的优化

- v-if 和 v-show 区别使用场景 v-if 真正的条件渲染，在切换过程中条件块内的事件监听器和子组件会被适当的销毁和重建。也是惰性的。初始条件为假的时候不会渲染。v-if 适用于不需要频繁切换的场景。
- computed 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值
- 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一且对应的 key 值，方便 Vue.js 内部机制精准找到该条列表数据
- 在组件销毁的时候手动删除使用 addEventListener 添加的事件
- 在项目开发好之后使用 Vue 的生产版本
- Vue 的组件化思想，对公共的代码进行抽离。

## Vue 首屏加载优化

- 因为 Vue 是单页面应用，在请求的时候会直接请求下来所有的组件，使用路由的懒加载。只在路由被访问的时候才加载对应的组件
- 使用 Vue 的懒加载图片插件
- 开启 gzip 压缩(需要服务端的配合)，文件体积会变小
- 使用第三方插件的时候按需加载
- 服务端的 SSR 渲染，加快首屏打开的速度？？？

## 常见的前端的优化技术

- 减少 http 的请求
- webpack 等前端工程化打包工具， 为了减少 http 的请求数量。将多个 css 和 js 文件合并为一个文件。
- 采用合理的结构，css 文件放在头部，js 文件放在底部。避免 css 的加载受到 js 加载的影响。
- 减少重排，重绘。 1. 改变样式的时候尽量使用 class 类名的切换(一次性更改多条 css 属性)而不是多次使用 style 操作样式。 2. 实现元素的动画时，设置 position 属性为 absolute 或者 fixed。这样动画的执行不会影响其他元素。
- 使用字体图标来代替图片图标， 字体图标的文件更小且不会失真。
- 压缩文件 使用 webpack 的插件进行 js，html，css 的压缩。还有就是在请求头中加入 gzip(目前最流行和最有效的压缩方法)标识来开启 gzip 压缩方式。
- 使用事件委托，一个事件处理程序就能管理一个类型的所有事件。节省内存。

- 使用 http2 协议？？？

1. 多路复用
2. 首部压缩
3. 优先级
4. 服务器推送

- 使用 CDN？？？
- 使用缓存

## 代码层次的前端优化

- 使用防抖和节流函数
- 当判断条件数量很多的时候采用 switch 代替 if-else
- flexbox 的性能比传统的浮动和定位要好。

## 针对图片的优化

- 使用雪碧图，合并多张图片为一张图片。
- 使用 Vue 的懒加载图片插件
- 响应式的图片， 比如在移动端就不需要下载和 pc 端一样大的图片。通过@media 来实现在不同的屏幕大小下，加载不同大小的图片。
- 降低图片的质量进行压缩(有些背景图压缩了一些质量看不出来) 可以使用 webpack 提供的插件
- 一些阴影或者是渐变的效果可以用 css3 来实现就不用了图片(图片的大小通常是 css 代码的几倍几十倍)
