# 中间件

* 业务处理过程中的中间环节(所以中间件要在路由之前定义，注册)
* 客户端发起的任何请求，到达服务器之后，都会触发全局的中间件。通过app.use(中间件函数)注册全局中间件
* 多个中间件 共享 req 和 res 属性，可以在上游给 req，res 定义属性，方法。在下游的中间件或者路由中使用。(可以在中间件中定义一些通用的函数，这样所有的路由都能使用这个函数，不然的话就得去每个路由里面把这个函数都给定义一遍)(例如一个记载当前请求所处时间的函数)
  
* 全局的中间件

```js
// 定义中间件函数
const vm = function(req,res,next) {
    console.log("我是一个中间件函数")
    next()
}
// 注册全局中间件函数
app.use(vm)
// 全局中间件函数的简化写法
app.use(function(req, res, next) {
    console.log("我是一个简化的中间件函数")
    next()
})
```

* 局部的中间件

```js
const vm = function(req, res, next) {
    console.log("我是局部的中间件")
    next()
}
// 使用单个局部中间件
app.get('/user',vm,(req, res)=> {
    console.log("i am get user")
})
// 使用多个局部中间件
app.get('/user',vm1,vm2,vm3(req, res)=> {
    console.log("i am get user")
})
app.get('/user',[vm1,vm2.vm3],(req, res)=> {
    console.log("i am get user")
})
```

## 中间件的分类

1. 应用级别的中间件: 绑定到 app 实例上的中间件
2. 路由级别的中间件: 绑定到 router 实例上的中间件
3. 错误级别的中间件: (err, req, res, next)有四个参数 专门用来捕获整个项目中发生的异常错误，使用 app.use() 全局注册。错误级别的中间件必须要放到所有的路由之后
4. express 内置的中间件: 1. express.static()快速托管静态资源 2. express.json() 解析 JSON 格式的请求体数据 3.express.urlencoded()解析 URL-encoded 格式的请求体数据

```js
// 只需要在路由之前注册一下这个中间件，不需要和 js 的 JSON 方法一样调用函数去解析得到的数据。
// 通过 express.json 这个中间件解析表单中的JSON格式的数据
app.use(express.json())
// 通过 express.urlencoded 这个中间件来解析表单中的 url-encoded 格式的数据
app.use(express.urlencoded({extended: false}))

```

5. 第三方的中间件，需要下载，导入，注册

## 跨域问题的解决

* cors中间件的使用

```js
//导入cors中间件
const cors = require('cors')
// 跨域中间件的注册必须在路由挂载之前
app.use(cors())
```

* 响应头部的相关字段

1. ```Access-Control-Allow-Origin: <origin> | *``` 允许哪些域的网站访问服务器，可以设置制定域名，或者通配符

## Session认证

* express-session 中间件的使用

```js
// 导入 session 模块
const session = require('express-session')
// 注册 session 全局中间件， 并进行配置
// session 中间件配置成功之后就可以使用req.session来访问和使用session对象，从而存储用户的关键信息
app.use(session({
    secret: 'xujie', // 属性的值可以为任意的字符串
    resave: false, // 固定写法
    saveUninitialized: true //固定写法
}))

// 登录的 API 接口
app.post('/api/login', (req, res) => {
    // 判断用户提交的登录信息是否正确
    if(req.body.username != 'xujie' || req.body.password !='xujie123') {
        return res.send({ status: 0, msg: '登陆失败' })
    }

    // 登陆成功之后，将用户信息保存到 session 中
    req.session.user = req.body  // 用户的信息
    req.session.isLogin = true // 用户的登录状态

    res.send({ status: 1, msg: '登录成功' })
})
```

## JWT认证

* jsonwebtoken (用于生成JWT字符串)  express-jwt (用于将 JWT 字符串还原成 JSON 对象)
* 需要定义一个 secret 密钥。在加密和还原过程中都需要使用这个 secret (secret 本质上就是一个字符串，定义的时候越是复杂越好)

```js
// 在用户登陆成功之后， 调用 jwt.sign() 方法生成 JWT 字符串
// 参数1：用户的信息对象
// 参数2：加密的密钥(定义的 secret 字符串)
// 参数3：配置对象，可以配置当前 Token 的有效期
const Token = jwT.sign({ username: 'xxx' }, secretKey, { expiresIn: '1h' })

// 在收到客户端发送的 JWT 字符串时，使用 expressJWt 将字符串解析成 JSON 对象
app.use(expressJWt({ secret: secretKey }))

// 登录的 API 接口
app.post('/api/login', (req, res) => {
  // 注意： 只要 expressJWt 中间件配置成功之后，就会把解析出来的用户信息，挂载到 req.user 属性上
  // 现在在这里就可以访问到 req.user 属性
  console.log(req.user)
})

// 如果 JWT 解析失败后会抛出错误，需要自己定义一个 全局的错误处理中间件 来捕获和处理错误
app.use((err, req, res, next) => {
    // 这个错误是由于 Token 解析失败导致的
    if(err.name === 'UnauthorizedError') {
        return res.send({
            status: 0,
            msg: '无效的Token'
        })
    }
})
```
