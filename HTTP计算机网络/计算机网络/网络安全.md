# 网络安全

## XSS

* 跨站脚本攻击、XSS其实就是Html的注入问题，攻击者的输入没有经过严格的控制进入了数据库，最终显示给来访的用户，导致可以在来访用户的浏览器里以浏览用户的身份执行Html代码，数据流程如下：攻击者的Html输入—>web程序—>进入数据库—>web程序—>用户浏览器。
* XSS更偏向于代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了）
* XSS利用的是用户对指定网站的信任

### 预防XSS

* 过滤用户的输入
* 真正麻烦的是，在一些场合我们要允许用户输入 HTML，又要过滤其中的脚本。Tidy 等 HTML 清理库可以帮忙，但前提是我们小心地使用。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。对于复杂的情况，我个人更倾向于使用简单的方法处理，简单的方法就是白名单重新整理。用户输入的 HTML 可能拥有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点，获取其中数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失——如果用户的某种复杂输入不能为解析器所识别（前面说了 HTML 不同于 XML，要求有很强的容错性），那么它不会成为漏网之鱼，因为白名单重新整理的策略会直接丢弃掉这些未能识别的部分。最后获得的新 HTML 元素树，我们可以拍胸脯保证——所有的标签、属性都来自白名单，一定不会遗漏。

## CSRF

* 跨站请求伪造 通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
* 冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。
* CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。
* CSRF利用的是网站对于用户浏览器的信任

1. 登录受信任的网站A,并在本地生成Cookie
2. 在不登出A的情况下(并且是在同一个浏览器中),访问危险网站B。B网站通过一些方式来诱导用户点击恶意链接。该链接能够生成对网站A的请求,并且这个请求是在用户的浏览器中发出的，这个请求会附带用户浏览器中的cookie信息。

### 预防CSRF

* 黑客只是利用用户浏览器中的cookie信息来伪造用户进行请求，但是黑客并不会知道cookie中的信息包含什么。

1. 服务器端判断referer这个字段，如果不是自己的网站，就返回错误。
2. CSRF Token方法， Token是服务器端生成的字符串。存储在客户端中。每次客户端请求的时候就会在请求中带上Token值。如果请求中的Token值和服务器端中的Token值对应不上，则请求失败。