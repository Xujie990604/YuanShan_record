# 基础概念

## 一些基础概念

* HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
* HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS
* http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。
* 默认HTTP的端口号为80，HTTPS的端口号为443
* HTTP协议永远都是客户端发起请求，服务器回送响应。
* HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系
* RFC使用来制定HTTP协议标准的文档

## http协议的特点

* 支持客户/服务器模式
* 简单快速

客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

* 灵活

HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

* 无连接

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。早期这么做的原因是请求资源少，追求快。随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。
后来通过Connection: Keep-Alive实现长连接

* 无状态

HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。

## http的瓶颈

* 一条连接上只可发送一个请求
* 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
* 请求/响应首部未经压缩就发送。首部信息越多延迟越大
* 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
* 可任意选择数据压缩格式。非强制压缩发送。

### SDPY的设计和功能

* SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接
* 多路复用流通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。
* 赋予请求优先级SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
* 压缩HTTP首部压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。
* 推送功能支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
* 服务器提示功能服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

### 全双工通信的WebSocket

* 一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据
* 由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。
* 推送功能支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
* 减少通信量只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少
* 握手·请求为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。
* 握手·响应对于之前的请求，返回状态码101 Switching Protocols的响应。成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。

### http2.0的特点

1. 采用二进制而非明文来打包
2. 多路复用
3. 修复队头堵塞
4. 允许设置请求优先级
5. 服务器推送
6. WebSocket等等
  
## http的优化

* TCP复用，TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端的TCP连接上，HTTP复用是指一个一个客户端的多个HTTP请求通过一个TCP连接进行处理。
* 内容缓存。将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
* 压缩，将文本数据进行压缩，减少宽带
* SSL加速。使用SSL协议对HTTP协议进行加密，在通道内加密并加速
* TCP缓冲：通过TCP缓冲技术，可以提高服务器端响应事件和处理效率，减少由于通信链路问题给服务器造成连接负担.

## MAC地址和内网地址

### 二层转发和三层转发

* 二层转发，同一子网内部，所有的设备处于同一个广播域，数据是基于MAC进行转发的
* 三层转发，跨子网时才会需要路由功能和路由器。转发是基于目的地的ip地址进行寻址

### MAC地址

* 媒体访问控制地址 (Media Access Control Address)，也称为局域网地址，以太网地址或物理地址它是一个用来确认网上设备位置的地址
* MAC地址是和网卡配对的，一个网卡就有一个MAC地址。MAC地址对应的是数据链路层。
* ARP (Address Resolution Protocol) 是一种用来解析地址的协议，它可以根据 IP 地址反查出对应的 MAC 地址。
* MAC地址一般来说是不可变的，在设备生产时就被烙上了唯一的标识。
* 你中午在公司点了份外卖，收货地址一定是写公司的地址；晚上回到家，再点外卖时就得把地址写成家 (IP 是动态的)。但无论在哪儿点外卖，订单上的姓名和手机号一定是你自己的 (MAC 地址)。中午外卖小哥把午餐送到公司门口，但收外卖的人肯定不止你一个 (多台设备在同一个 broadcast 网络里)，因此他会通过手机号和姓名来找到你。

### ip地址

* ip地址是可变的。ip地址对应的是网络层。
* 而IP是分层的，这和我们常用的通讯地址一致，类似于 中国/北京/海淀/后场村路/xx楼/xx号。负责整个中国的设备只要知道北京在哪，找到北京之后，负责北京的设备只要海淀在哪，负责海淀的设备只要知道后场村在哪，这样逐级查找。每个设备需要存储的信息较少。
* MAC地址具有扁平结构，无论到哪里都不会变化，比如一台智能手机无论它到哪里，它的MAC地址不会改变。而IP地址具有层次结构，当主机移动时，主机的IP地址随着连接到的网络的改变而改变，
* IP地址：分配每个设备的IP地址，使设备位于网络上。
* 公网ip地址是由运营商进行分配的IP地址。是独一无二的。
* 内网(局域网)ip是由交换机或者是路由器分配的。内网的计算机可以向公网发送连接请求，但是公网无法向内网发送连接请求。
* 百度搜索ip出来的是公网ip，CMD中显示的是内网ip

## get和post的区别

* 谈到get和post的区别时，一定要从两个方面。一是浏览器的http协议方面。二是经过了一些库的封装。

### get

* 读取一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如GET一下，用户就下单了，返回订单已受理，这是不可接受的。没有副作用被称为幂等。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端

* 可以被收藏为收藏夹
* 能被缓存
* 参数保留在浏览器历史中
* 对URL的长度有限制
* 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！
* 数据在 URL 中对所有人都是可见的。

### post

* 在页面里form>标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的。不幂等也就意味着不能随意多次执行。因此也就不能缓存。比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求的结果被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的下单成功界面，却又没有真的在服务器下单。那是一件多么滑稽的事情。因为POST可能有副作用，所以浏览器实现为不能把POST请求保存为书签。想想，如果点一下书签就下一个单，是不是很恐怖？。此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。post的幂等问题也需要根据实际情况来定制。

* 不能被收藏为收藏夹
* 不能缓存
* 参数不会保留在浏览器历史中
* URL长度没有限制
* POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中
* 数据不会显示在 URL 中

### 对比讲解

* 本质上get和post的底层都是使用tcp传输的。get和post本质上没有区别，只是报文格式不同。
* 在服务器支持的情况下，get和post的格式可以混着来。但是在原生的http协议中GEt请求没有body，只有url，请求数据放在url中，post的请求数据放在body中。
* 其实post和get都是不安全的，因为http是明文传输。想要安全就必须要使用https
* get的长度限制问题不是http协议的内容，大多都是服务器和及客户端添加的限制，避免恶意输入长URL来攻击，占用性能。
* http协议中并没有说明，post时header和body分开发送，产生两个tcp，应该是框架的请求方式。并不是post的必然行为。