# 列表渲染

## v-for（数组）

* 支持两个参数(item, index) in items。item是数组中的每一个项目，index是项目对应的索引

## v-for(对象)

* 支持三个参数(item, name, index) in items。 item是对象中的每一个属性，name是属性的键名，index是索引

## v-for可以用来遍历数字

* 用来生成相同类型的连续数字的class类名还是挺香的

## 类名(DOM属性)中使用模板字符串

```js
<li :class="`list_0${index}`" v-for="(item,index) in lists" :key="index">
    {{item}}
</li>
```

## v-for和v-if一起使用

* 现在v-for和v-if一起使用会报错，不知道是Vue的要求还是vsCode插件的要求
* 不推荐在同一元素上使用v-for和v-if
* 当处于同一节点时，v-for的优先级别比v-if的优先级别高，可以实现为部分项渲染节点。(比如说只有那些user.money > 5000的人才会被渲染的话，这个功能使用计算属性来实现比较好)
* 如果想要依照条件控制整个列表(ul而不是单个的li)是否渲染时，把v-if放在外层(如果某一个条件为真的话，才加载这个列表)

## Vue的虚拟DOM

![vue的虚拟DOM](./../img/virDOM.jpg "Vue的虚拟DOM图")

* 渲染函数 vue通过编译将template模板转换为渲染函数(rander)，执行渲染函数就能够得到Virtual DOM。如果编码过程中不写template而是直接写rander函数能够得到更高的性能。
* Virtual DOM虚拟结点  是结点的描述对象，描述了应该怎样去创建真实的DOM结点。
* patch算法  可以将Virtual DOM渲染成真实的DOM。但是patch算法中还使用了diff算法。使得Vue可以不必绘制全部的DOM结点。而是对比新旧结点的不同。仅仅对需要更新的DOM结点进行更新。

### js操作真实DOM的代价

* 一次操作需要更新10个DOM节点。原生的js会操作DOM十次。最多可能绘制十次页面。浪费性能。
* 真实DOM是DOM树(就是HTML的各种Tag代码)，虚拟DOM就是js代码中的对象。
* 无论是真实DOM还是虚拟DOM，最终都是用DOM API(document.createElement() push()等原生js中的DOM方法)去更新结点。如何去更新结点决定了性能的好坏。

### 虚拟DOM

#### Vue中的虚拟DOM

* 一次操作需要更新十个DOM。页面的更新先全部反映在JS对象(虚拟DOM)中，然后通过diff算法对新旧两个虚拟DOM进行对比，把这次更新产生的差异保存到本地的一个js对象中。最终根据差异对象来更改(patch打补丁)原来的真实的DOM结构。
* 虚拟DOM更适合批量修改DOM
* 因为DOM操作的执行速度远不及js的运算速度快。因此将大量的DOM操作搬运到js中。运用patch算法中的diff算法计算出真正需要更新的结点。最大限度的减少DOM的操作。

#### diff算法

* diff算法用来比较两个Virtual DOM树的差异，diff算法只会比较同一个层级的元素。diff算法不会跨层级比较。因为跨层级改变DOM的情况很少。
* diff算法在同层级比较结点时，例如在比较第二层的div时，发现新旧虚拟结点有不同，不会再进行div下一层的比较而是直接将第二层结点整个更新(即使第三层的子节点有相同的结点也不再复用，这样做的目的应该是为了减少diff算法的时间复杂度)
* 采用深度优先算法

## Vue的DOM更新策略

* Vue 在更新 DOM 时是 异步执行 的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

## 维护状态

* key值最好要使用的是item.id，与列表一一对应并且不会重复，唯一标识。(可以使用uuid或者自定义个每次调用都会递增的函数)

* key值的作用是为了更加高效的更新虚拟DOM。
* key属性是vnode的标记，在diff过程中可以提高diff的效率
* key值最好使用字符串或者数字的数据基本类型
* 列表循环的时候不使用key值的时候，会采用就地复用的策略。加了key值会根据标识来更新DOM。

* key被应用在组件上时，当key改变的时候Vue认为一个新的元素产生了，从而会新插入一个元素来代替原有的元素。会触发组件的生命周期钩子函数。
* 在切换的时候如果两个元素拥有很类似的结构，那么Vue会复用DOM结构。需要加入key值来区分这两个DOM。(如果不加入key值，这两个input表单中的数据会被复用。 如果加入了key值，在组件切换时会完整的触发组件的生命周期函数)