# 优化

## Vue的优化

* v-if和v-show区别使用场景 v-if真正的条件渲染，在切换过程中条件块内的事件监听器和子组件会被适当的销毁和重建。也是惰性的。初始条件为假的时候不会渲染。v-if适用于不需要频繁切换的场景。
* computed 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值
* 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一且对应的key 值，方便 Vue.js 内部机制精准找到该条列表数据
* 在组件销毁的时候手动删除使用addEventListener添加的事件
* 在项目开发好之后使用Vue的生产版本
* Vue的组件化思想，对公共的代码进行抽离。

## Vue首屏加载优化

* 因为Vue是单页面应用，在请求的时候会直接请求下来所有的组件，使用路由的懒加载。只在路由被访问的时候才加载对应的组件
* 使用Vue的懒加载图片插件
* 开启gzip压缩(需要服务端的配合)，文件体积会变小
* 使用第三方插件的时候按需加载
* 服务端的SSR渲染，加快首屏打开的速度？？？

## 常见的前端的优化技术

* 减少http的请求
* webpack等前端工程化打包工具， 为了减少http的请求数量。将多个css和js文件合并为一个文件。
* 采用合理的结构，css文件放在头部，js文件放在底部。避免css的加载受到js加载的影响。
* 减少重排，重绘。 1. 改变样式的时候尽量使用class类名的切换(一次性更改多条css属性)而不是多次使用style操作样式。 2. 实现元素的动画时，设置position属性为absolute或者fixed。这样动画的执行不会影响其他元素。
* 使用字体图标来代替图片图标， 字体图标的文件更小且不会失真。
* 压缩文件 使用webpack的插件进行js，html，css的压缩。还有就是在请求头中加入gzip(目前最流行和最有效的压缩方法)标识来开启gzip压缩方式。
* 使用事件委托，一个事件处理程序就能管理一个类型的所有事件。节省内存。

* 使用http2协议？？？

1. 多路复用
2. 首部压缩
3. 优先级
4. 服务器推送

* 使用CDN？？？
* 使用缓存

## 代码层次的前端优化

* 使用防抖和节流函数
* 当判断条件数量很多的时候采用switch代替if-else
* flexbox的性能比传统的浮动和定位要好。

## 针对图片的优化

* 使用雪碧图，合并多张图片为一张图片。
* 使用Vue的懒加载图片插件
* 响应式的图片， 比如在移动端就不需要下载和pc端一样大的图片。通过@media来实现在不同的屏幕大小下，加载不同大小的图片。
* 降低图片的质量进行压缩(有些背景图压缩了一些质量看不出来) 可以使用webpack提供的插件
* 一些阴影或者是渐变的效果可以用css3来实现就不用了图片(图片的大小通常是css代码的几倍几十倍)