# 响应式数据

- Vue 能够跟踪对响应式对象属性的访问与更改操作(对 Proxy 的更改和访问会被 Vue 跟踪到， 对 obj 的更改和访问不会被 Vue 跟踪到)
- 在 Vue3 中，状态都是默认深层响应式的

## reactive()

- 仅对对象类型有效(对象，数组，Set，Map)等。(string, number, boolean)等类型无效
- Proxy 是基于属性的访问进行响应式跟踪的。所以只能对引用类型进行跟踪。
- 因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地"替换"一个响应式对象，因为这将导致对初始引用的响应性连接丢失
- 为保证访问代理的一致性，对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身。
- 响应式对象的属性被赋值，解构至本地，或者当做函数的参数传递时会失去响应式(!!!仅当属性为非引用类型值的时候)(本质上就是只有被 proxy 代理的堆内存中的数据才具有响应式)

## ref()

- reactive()不能为 string, number, boolean 类型声明响应式，是因为 js 中没有给这三种值引用数据类型
- ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象(将一个基本类型的值变成引用类型的值之后，就可以把这个属性赋值，解构，或者是当做函数的参数传递了)

### 解包

- 当 ref 在模板中作为顶层属性(如果一个属性并不是顶层属性，可以使用解构的方式解出来)被访问时，它们会被自动"解包"，所以不需要使用 .value(若只是想展示数据那么无论是不是顶层对象都不需要.value, 只是说在{{}}语法中想把属性当做表达式计算时，只有顶层属性不需要加 .value)
- 当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样(不需要使用 .value 来取值)
- 当 ref 被嵌套在响应式数组中时，不会被解包
