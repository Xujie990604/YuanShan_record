# 路由

* 路由是网络工程里面的术语
* 路由就是通过互联网的网络把信息从源地址传输到目的地址的活动

## 映射表

* 路由表的本质上就是一个映射表，决定了数据包的指向。

## 前端渲染后端渲染

### 后端的渲染(服务端渲染)

* 原来的话后端使用jsp写页面，html+css+java java代码就直接从数据库中读取数据，并且将它动态的放在页面上
* 以前的网页是没有ajax技术的。整个页面都是重新获取的
* 浏览器输入RUL，直接将RUL发送给后端，后端直接返回页面
* 后端路由就是由后端处理URL和页面之间的映射关系
* 后端渲染直接交给客户端展示的话，有利于SEO的优化。
* 结构样式和数据全都糅合在一起，编写和维护都是很恶心的。

### 前后端分离的阶段

* 随着ajax的出现
* 后端只负责提供数据，不负责任何页面的功能
* 后端就是一个提供API接口的服务器
* 在浏览器输入URL的话，去静态服务器下载html+css+js，html和css浏览器能够直接的渲染到页面，然后执行js代码，根据ajax去后端服务器请求数据，然后再根据请求到的数据增删改查DOM和CSS，然后再将新的页面渲染到页面上。
* 根据不同的URl下载不同的html+css+js，静态服务器中存在很多套html+css+js
* 这个阶段叫做前端渲染
* 前后端任务的分离，后端负责数据，前端负责交互和可视化

#### 单页面(spa)富应用阶段

* 在前后端分离的基础上加上了一层前端路由
* 静态资源服务器上只有一套html+css+js，在获取的时候会一次性获得所有文件，只不过不全部显示
* 然后根据不同的URL，从获取的html+css+js中抽离对应的部分(在vue中也就是对应的组件)
* 页面和URl的映射关系由前端路由来管理
* 改变URL的时候，页面是不进行整体的刷新的

## 如何改变URL而不刷新页面

* hash
* html5的history模式，类似是栈的模式

## 安装和使用

* npm install vue-router --save因为在运行时也需要路由插件

### 使用

* 导入路由对象，并且调用Vue.use(VueRouter),Vue.use()是安装的意思，任何插件在使用前都需要在Vue中安装一下。执行完Vue.use(VueRouter)之后内部自动执行VueRouter.install()
* 创建路由实例并且导出，并且配置路由映射
* 在Vue实例中挂载导入的路由实例
* 在模块化开发的时候，如果是一个目录，默认会去找文件夹下的index文件

## VueRouter源码的解析

* 所有的组件都继承自Vue类的原型
* 所以在main.js中在Vue的原型链上定义属性或者方法的话，每个Vue组件都可以拿到这个属性或者方法。

## router-link

* 给router-link添加一个tag特性，就可以指定router-link会被渲染成什么
* to属性，源码里面使用的是pushState()会留下痕迹
* replace属性，添加replace属性之后，路由的跳转就不会留下痕迹。
* 默认情况下，被选中的router-link都会被添加一个类名，也可以去router的实例里面添加一个linkActiveClass的属性，用来修改默认添加的类名。

## $router属性

* vue-router给每一个组件都添加了$router的属性
* 通过this.$router可以访问到路由对象实例(this指代当前的组件)
* $router取到的就是router实例(和main.js文件里面引用的那个vueRouter是同一个)(用来使用路由变换的方法)。$route取到的是当前活跃的某个路由对象(可以用来取动态路由的参数)。

## 脚手架打包dist

* js文件会分成几份，app.js是当前应用程序的所有业务代码  vender.js是提供商，第三方的文件(例如Vue/vue-router/axios) manifest.js为了打包的代码做底层的支撑
* 要是使用了路由懒加载的话，有几个懒加载的路由就会在dist文件中多几个js文件

## keep-alive与router的邂逅

* keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
* 可以让keep-alive内部的组件在路由的切换时不被重新创建和销毁。也就是会保留组件内部的状态。

### activated和deactivated

* 在当前组件活跃和失活的时候被调用
* 这两个状态只有在组件被keep-alive包含时才有效。

### include和exclude属性

* 可以指定哪些组件被保持状态，哪些组件不被保持状态
* 添加的是组件的name，这个name终于被用到了
* 还可以使用正则

## 重复点击路由报错

* 因为$router.push()的方法是promise，因为没有失败的回调函数，所以才会报错。
* 1. 解决方法重写push方法，
* 2. this.$router.push('/').catch(err => {err})手动加上失败的回调函数
