# 函数式编程

## 二、一等公民的函数

* 函数可以当做值来使用，当做参数、传递给变量、存进数组里面
* JS 在编程过程中需要额外的关注 this 的使用，在很多情况需要使用 bind() 函数来指定 this

## 三、纯函数

> 纯函数：即相同的输入，永远会得到相同的输出，并且没有任何可观察的副作用

```js
// slice() 函数是纯函数，splice() 不是纯函数

// 不纯的
// checkAge 的结果取决于外部的变量 minimum，因为这个函数引入了外部的环境，从而增加了认知负荷
var minimum = 21;

var checkAge = function(age) {
  return age >= minimum;
};


// 纯的
// checkAge 的结果只有输入有关，能够保留纯粹性
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```

### 3.1 副作用

> 副作用：一切除了结果计算之外发生的事情，副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互

副作用可能包含：更改文件系统，数据库插入记录，发送 http 请求，可变数据，打印log，获取用户输入，DOM查询，访问系统状态

* 副作用让一个函数变的不纯：如果函数需要和外部的事物打交道，那么无法保证相同的输入一定返回相同的输出
* 函数只是两种数值之间的关系：函数仅仅描述了输入到输出的映射

```js
// 实际上结果还是需要进行计算的，只是用对象来表示一个结构清楚的映射
const toLowerCase = {
  "A": "a",
  "B": "b",
  "C": "c",
  "D": "d"
}
toLowerCase["A"];  // "c"
```

### 3.2 追求纯函数的理由

#### 可缓存性

* TODO：自己实现一个函数，能够包装其他函数实现可缓存性
* 对于 HTTP 请求，我们无法缓存 HTTP 请求的结果，但是能缓存一个 HTTP 请求的函数(相同的输入，总会输出一个请求相同地址的函数)

#### 可移植性、自文档性

* 纯函数完全是自给自足的，纯函数的依赖很明确，因此更易于观察和理解
* 可移植性是一个强大的特性：纯函数的执行结果与环境无关，可以在任何的地方运行它

#### 可测试性

* 纯函数让测试更加的简单：在测试前我们不需要去伪造一个真实的环境

#### 合理性

* 引用透明：如果一段代码可以替换成它执行的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的

#### 并行代码

* 我们可以并行运行任意纯函数，因为纯函数根本不需要访问`共享的内存`，而且根据其定义，纯函数也不会因为副作用而进入`竞争态`
* NOTE: 并行代码在 JS 服务端以及使用了 WEB worker 的浏览器那里是非常容易实现的，因为它们使用了线程(thead)

## 四、柯里化

* 柯里化(curry): 只传递给函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数
