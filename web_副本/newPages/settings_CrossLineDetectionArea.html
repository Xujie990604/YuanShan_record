<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">
		<link href="../css/mui.css" rel="stylesheet" />
		<link href="../css/iconfont.css" rel="stylesheet" />
		<style>
			html,
			body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				color: #ffffff;
				font-size: 15px;
				overflow: hidden;
				background-color: #000000;
			}
			
			ul,
			li {
				margin: 0;
				padding: 3px 0;
				list-style: none;
			}
			
			#drawDiv {
				width: 100%;
				height: 100%;
				box-sizing: border-box;
				overflow: hidden;
				position: absolute;
				left: 0;
				background-color: #000;
			}
			
			#canvas {
				background-size: 100% 100%;
				margin: 0;
				padding: 0;
			}
			
			#drawback {
				position: fixed;
				top: 10px;
				left: 10px;
			}
			
			#drawbtn {
				width: 50px;
				height: 100%;
				position: absolute;
				right: 0;
				top: 0;
				z-index: 800;
			}
			
			#drawbtn button {
				width: 30px;
				height: 30px;
				border: 0px;
				background-color: rgba(0, 0, 0, 0);
				color: #fff;
				font-size: 25px;
				font-weight: 500;
				padding: 0px;
			}
			
			#drawbtn ul {
				width: 100%;
				height: 100%;
				display: flex;
				display: -webkit-flex;
				flex-direction: column;
				-webkit-flex-direction: column;
				justify-content: center;
				-webkit-justify-content: center;
				align-items: center;
				-webkit-align-items: center;
			}
			
			#drawbtn #areabtn {
				background-color: #000000;
			}
			
			#areabtn li {
				margin: 30px 0;
			}
			
			.wapp-side-btn-back {
				background: url('../images/return.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-add {
				background: url('../images/motionDetection0/add_normal.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-del {
				background: url('../images/motionDetection0/delete_normal.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-commit {
				background: url('../images/motionDetection0/checked.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-ab-select {
				background: url('../images/motionDetection0/checked.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-a-select {
				background: url('../images/motionDetection0/checked.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.wapp-side-btn-b-select {
				background: url('../images/motionDetection0/checked.png') no-repeat;
				background-size: 100% 100%;
			}
			
			.ui-drawbtn-invisible {
				visibility: hidden;
			}
			
			.canvas-style {
				margin-top: 30px;
				margin-left: 50px;
				margin-right: 50px;
				background: url("../images/no_photo@3x.png") center center no-repeat;
				background-size: 100px 80px;
				background-color: #3D3E41;
			}
			
			button:disabled {
				opacity: 0.35;
			}
			
			.select-color {
				opacity: 0.7!important;
			}
			
			#goBack {
				width: 28px!important;
				height: 28px!important;
			}
		</style>
	</head>

	<body>
		<div id="drawDiv">
			<div class="canvas-style" id="canvasStyle" style="display: none">
				<canvas id="canvas" width="" height=""></canvas>
			</div>
			<div id="drawbtn" class="ui-drawbtn-invisible">
				<div id="drawback">
					<button type="button" id="goBack" class="wapp-side-btn-back"></button>
				</div>
				<ul id="tripbtn" class="wapp-selected wapp-hide">
					<li><button type="button" id="tripadd" class="iconfont icon-add"></button></li>
					<li><button type="button" id="tripAB" class="iconfont icon-cross_ab"></button></li>
					<li><button type="button" id="triptoA" class="iconfont icon-cross_a"></button></li>
					<li><button type="button" id="triptoB" class="iconfont icon-cross_b"></button></li>
					<li><button type="button" id="tripdel" class="iconfont icon-delete_normal"></button></li>
					<li><button type="button" id="tripcommit" class="iconfont icon-affirm"></button></li>
				</ul>
			</div>
		</div>
	</body>
	<script src="../js/dsbridge.min.js"></script>
	<script src="../js/common.js"></script>
	<script src="../js/libs/md5.js"></script>
	<script src="../js/libs/jquery-3.4.1.min.js"></script>
	<script src="../js/libs/sha2.js"></script>
	<script src="../js/resource.js"></script>
	<script src="../js/Utils.js"></script>
	<script src="../js/mui.js"></script>
	<!--	<script src="../js/immersed.js"></script>-->
	<!--<script src="../js/customSetting.js"></script>-->
  <script id="langScript"></script>
	<script type="text/javascript">
		var langTip;
		var drawDiv = document.getElementById("drawDiv");
		var areaadd = document.getElementById("areaadd");
		var areadel = document.getElementById("areadel");
		var self;
		var parentW;
		var CrossLineGridServiceObj;
		var GridService;
		//canvas画图相关参数
		var canvas;
		var context;
		var imgSrc = ""; //获取第一帧图返回数据
		var imgTimeout = false; //获取第一帧图是否超10秒
		var initDrawFlag = false;
		canvas = document.getElementById("canvas");
		context = canvas.getContext("2d");
		var isLineArea;
		//越界和区域绘图的初始化坐标点，当设备侧没有配置绘制区域时，采用该默认坐标值
		var initLinePoints = [{
				'X': 250,
				'Y': 20
			}, {
				'X': 250,
				'Y': 230
			}, {
				'X': 250,
				'Y': 100
			},
			{
				'X': 200,
				'Y': 150
			}, {
				'X': 150,
				'Y': 150
			}, {
				'X': 100,
				'Y': 100
			}
		];
		//越界和区域绘图的坐标点共享数据，越界取前两个，区域取全部的
		var linePoints = [{
				'X': 250,
				'Y': 50
			}, {
				'X': 250,
				'Y': 300
			}, {
				'X': 250,
				'Y': 100
			},
			{
				'X': 200,
				'Y': 150
			}, {
				'X': 150,
				'Y': 150
			}, {
				'X': 100,
				'Y': 100
			}
		];
		//越界和区域绘图共享的配置信息，越界取前四个，区域取全部的
		var lineCfgInfo = {
			'ID': 0,
			'Enabled': 1,
			'Sensitivity': 75,
			'DisplayEnabled': '',
			'TargetSize': 1,
			'PointNum': 4
		};
		//设备侧的数据
		var oriLinePoints = [{
				'X': 0,
				'Y': 0
			}, {
				'X': 0,
				'Y': 0
			}, {
				'X': 0,
				'Y': 0
			},
			{
				'X': 0,
				'Y': 0
			}, {
				'X': 0,
				'Y': 0
			}, {
				'X': 0,
				'Y': 0
			}
		];
		var linePointNum = -1; //最大到0--5，-1为无效点
		checkType(localStorage.AppType); //加载特定样式
		mui.init();
		var typeLan = initLang();
		langTip = typeLan.lang;
		initPage();
		initData();

		function initPage() {
			var Url = "web/newPages/settings_CrossLineDetectionArea.html";
			var self = dsBridgeFuncSyn.getWebParam(Url);
			self = JSON.parse(self);
			CrossLineGridServiceObj = JSON.parse(JSON.stringify(self.CrossLineGridService));
			GridService = JSON.parse(JSON.stringify(CrossLineGridServiceObj));
			lineCfgInfo.Enabled = GridService.LineInfoList[0].Enabled;
			lineCfgInfo.Direction = GridService.LineInfoList[0].Direction;
			lineCfgInfo.PointNum = 2;
			lineCfgInfo.PointList = [];
			lineCfgInfo.PointList.push(GridService.LineInfoList[0].StartPoint);
			lineCfgInfo.PointList.push(GridService.LineInfoList[0].EndPoint);
			var enabled = lineCfgInfo.PointList.every(function(item) { // 当获取的数据为空时，lineCfgInfo.Enabled =0，默认图标+为高亮
				return item.X == 0 && item.Y == 0
			})
			if(enabled) {
				lineCfgInfo.Enabled = 0;
			}
		}

		function doTask() {
			drawbtn.classList.remove("ui-drawbtn-invisible");
			canvasWidth = drawDiv.offsetWidth - 50 - 50;
			canvasHeight = drawDiv.offsetHeight - 60;
			if((canvasWidth - canvasHeight) < 100) {
				setTimeout(doTask, 200);
				return;
			}
			canvas.style.width = canvasWidth + 'px';
			canvas.style.height = canvasHeight + 'px';
			document.getElementById("canvasStyle").style.width = canvasWidth + 'px';
			document.getElementById("canvasStyle").style.height = canvasHeight + 'px';
			document.getElementById("canvasStyle").style.display = "block";
			canvas.width = canvasWidth;
			canvas.height = canvasHeight;
			initDrawAreas();
		}

		/**
		 * 数据初始化
		 */
		function initData() {
			//			dsBridgeFuncAsyn.setScreenRotation("1", function() {

			setTimeout(doTask, 500);

			//			});
		}

		/*
		 * 初始化绘图区域
		 */
		function initDrawAreas() {
			dsBridgeFuncSyn.showLoading();
			setTimeout(function() {
				dsBridgeFuncSyn.dismiss();
				if(!initDrawFlag) {
					timeoutDo();
				}
			}, 10000);
			dsBridgeFuncAsyn.getFirstImg(function(path) {
				dsBridgeFuncSyn.dismiss();
				var data = JSON.parse(path);
				if(imgTimeout) return;
				if(data.statusCode == "0") {
					imgSrc = data.param;
					canvas.style.backgroundImage = 'url(' + imgSrc + ')';
				}
				drawbtn.classList.remove("ui-drawbtn-invisible");
				getDrawAreas();
				context.clearRect(0, 0, canvas.width, canvas.height);
				drawIntrusion();
				initDrawFlag = true;
				canvas.addEventListener("touchstart", drawLineEvent, false);
				canvas.addEventListener("touchmove", drawLineEvent, false);
				canvas.addEventListener("touchend", drawLineEvent, false);
			});
			changeTripBtnStatus(lineCfgInfo.Enabled, lineCfgInfo.Direction);
		}

		/*
		 * 获取设备侧数据并处理
		 */
		function getDrawAreas() { //获取到设备侧的数据并处理
			for(var num = 0; num < lineCfgInfo.PointNum; num++) {
				linePoints[num].X = Math.ceil(lineCfgInfo.PointList[num].X * canvas.width / 10000);
				linePoints[num].Y = Math.ceil(lineCfgInfo.PointList[num].Y * canvas.height / 10000);
				oriLinePoints[num].X = linePoints[num].X;
				oriLinePoints[num].Y = linePoints[num].Y;
			}
		}
		//处理越界和区域获取绘图数据
		mui('#tripbtn').on('tap', 'button', function() {
			if(this.id == "tripadd") {
				lineCfgInfo.Enabled = 1;
				for(var num = 0; num < 6; num++) {
					linePoints[num].X = initLinePoints[num].X;
					linePoints[num].Y = initLinePoints[num].Y;
				}
			} else if(this.id == "tripAB") {
				lineCfgInfo.Direction = 0;
			} else if(this.id == "triptoA") {
				lineCfgInfo.Direction = 1;
			} else if(this.id == "triptoB") {
				lineCfgInfo.Direction = 2;
			} else if(this.id == "tripdel") {
				lineCfgInfo.Enabled = 0;
				for(var num = 0; num < 6; num++) {
					linePoints[num].X = 0;
					linePoints[num].Y = 0;
				}
			} else if(this.id == "tripcommit") {
				saveCommit();
			}
			changeTripBtnStatus(lineCfgInfo.Enabled, lineCfgInfo.Direction);
			drawCrossLine();
		})

		/*
		 * 修改按钮状态
		 * @param {Number} isEnable
		 * @param {Number} direct
		 */
		function changeTripBtnStatus(isEnable, direct) {
			if(isEnable) {
				tripAB.classList.remove("select-color");
				triptoA.classList.remove("select-color");
				triptoB.classList.remove("select-color");
				tripadd.disabled = true;
				tripdel.disabled = false;
				tripAB.disabled = false;
				triptoB.disabled = false;
				triptoA.disabled = false;
				if(direct == 0) {
					tripAB.classList.add("select-color");
					tripAB.disabled = true;
				} else if(direct == 1) {
					triptoA.classList.add("select-color");
					triptoA.disabled = true;
				} else if(direct == 2) {
					triptoB.classList.add("select-color");
					triptoB.disabled = true;
				}
			} else {
				tripadd.disabled = false;
				tripdel.disabled = true;
				tripAB.disabled = true;
				triptoB.disabled = true;
				triptoA.disabled = true;
			}
		}

		/*
		 * 获取图片超时后重绘图形
		 */
		function timeoutDo() {
			if(imgSrc == "") {
				imgTimeout = true;
				drawbtn.classList.remove("ui-drawbtn-invisible");
				getDrawAreas();
				context.clearRect(0, 0, canvas.width, canvas.height);
				drawIntrusion();
				canvas.addEventListener("touchstart", drawLineEvent, false);
				canvas.addEventListener("touchmove", drawLineEvent, false);
				canvas.addEventListener("touchend", drawLineEvent, false);
			}
		}

		/*
		 * 绘制越界线
		 */
		function drawCrossLine() {
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.globalAlpha = 1;
			if(lineCfgInfo.Enabled == 0) {
				return;
			}
			context.beginPath();
			context.strokeStyle = "red";
			context.lineWidth = 2;
			context.moveTo(linePoints[0].X, linePoints[0].Y);
			context.lineTo(linePoints[1].X, linePoints[1].Y);
			context.stroke();
			context.restore();

			context.beginPath();
			context.strokeStyle = "black";
			context.arc(linePoints[0].X, linePoints[0].Y, 5, 0, 2 * Math.PI);
			context.fillStyle = "white";
			context.fill();
			context.stroke();
			context.restore();

			context.beginPath();
			context.strokeStyle = "black";
			context.arc(linePoints[1].X, linePoints[1].Y, 5, 0, 2 * Math.PI);
			context.fillStyle = "white";
			context.fill();
			context.stroke();
			context.restore();
			drawCrossVerticalLine(lineCfgInfo.Direction);
		}

		/*
		 * 绘制越界线
		 */
		function drawCrossVerticalLine(dicrect) {
			function calPointsOnAng(reFerLinePoints, len, ang) {
				var calLinePoints = [{
					'X': 0,
					'Y': 0
				}, {
					'X': 0,
					'Y': 0
				}];
				var angle = Math.atan2(reFerLinePoints[0].Y - reFerLinePoints[1].Y, reFerLinePoints[0].X - reFerLinePoints[1].X) * 180 / Math.PI;
				var angle1 = (angle + ang) * Math.PI / 180;
				var angle2 = (angle - ang) * Math.PI / 180;
				calLinePoints[0].X = reFerLinePoints[1].X + len * Math.cos(angle1);
				calLinePoints[0].Y = reFerLinePoints[1].Y + len * Math.sin(angle1);
				calLinePoints[1].X = reFerLinePoints[1].X + len * Math.cos(angle2);
				calLinePoints[1].Y = reFerLinePoints[1].Y + len * Math.sin(angle2);
				return calLinePoints;
			}

			function drawArrow(reFerLinePoints, len, ang, character, charPoint) {
				var linePoints7 = calPointsOnAng(reFerLinePoints, len, ang);
				var linePoints8 = calPointsOnAng(reFerLinePoints, len + 10, ang);
				context.beginPath();
				context.strokeStyle = "red";
				context.lineWidth = 2;
				context.moveTo(reFerLinePoints[0].X, reFerLinePoints[0].Y);
				context.lineTo(reFerLinePoints[1].X, reFerLinePoints[1].Y);
				context.moveTo(charPoint.X, charPoint.Y);
				context.lineTo(linePoints7[0].X, linePoints7[0].Y);
				context.lineTo(linePoints7[1].X, linePoints7[1].Y);
				context.lineTo(charPoint.X, charPoint.Y);
				context.closePath();
				context.fillStyle = "red";
				context.fill();
				if(character == "A") {
					context.strokeText(character, linePoints8[0].X, linePoints8[0].Y);
				} else {
					context.strokeText(character, linePoints8[1].X, linePoints8[1].Y);
				}
				context.stroke();
				context.restore();
			}
			var xCenter = (linePoints[0].X + linePoints[1].X) / 2;
			var yCenter = (linePoints[0].Y + linePoints[1].Y) / 2;
			var LinePoints1 = [{
				'X': linePoints[0].X,
				'Y': linePoints[0].Y
			}, {
				'X': xCenter,
				'Y': yCenter
			}];
			linePoints2 = calPointsOnAng(LinePoints1, 30, 90); //箭头位置
			linePoints3 = calPointsOnAng(LinePoints1, 32, 90); //字母位置
			var linePoints5 = [{
				'X': xCenter,
				'Y': yCenter
			}, {
				'X': linePoints2[0].X,
				'Y': linePoints2[0].Y
			}];
			var linePoints6 = [{
				'X': xCenter,
				'Y': yCenter
			}, {
				'X': linePoints2[1].X,
				'Y': linePoints2[1].Y
			}];

			if(dicrect == 1 || dicrect == 0) //箭头B->A
			{
				drawArrow(linePoints5, 10, 45, "A", linePoints3[0]);
			}
			if(dicrect == 2 || dicrect == 0) //箭头A->B
			{
				drawArrow(linePoints6, 10, 45, "B", linePoints3[1]);
			}
		}

		/**
		 * 绘图
		 */
		function drawIntrusion() {
			context.globalAlpha = 1;
			if(lineCfgInfo.Enabled == 0) {
				return;
			}
			context.beginPath();
			context.strokeStyle = "#F7615E";
			context.lineWidth = 2;
			context.moveTo(linePoints[0].X, linePoints[0].Y); //6边型，可能三，四，五边型
			for(var i = 0; i < lineCfgInfo.PointNum; i++) {
				context.lineTo(linePoints[i].X, linePoints[i].Y);
			}
			context.lineTo(linePoints[0].X, linePoints[0].Y);
			context.stroke();
			context.restore();
			for(var i = 0; i < lineCfgInfo.PointNum; i++) {
				context.beginPath();
				context.strokeStyle = "black";
				context.arc(linePoints[i].X, linePoints[i].Y, 5, 0, 2 * Math.PI);
				context.fillStyle = "white";
				context.fill();
				context.stroke();
				context.restore();
			}
			drawCrossVerticalLine(lineCfgInfo.Direction);
		}

		/**
		 * canvas绘图相关的函数
		 * @param {Object} event
		 */
		function drawLineEvent(event) {
			var touchPoint = event.touches[0];
			var xPosition = touchPoint.clientX - 50;
			var yPosition = touchPoint.clientY - 30;
			switch(event.type) {
				case "touchstart":
					checkTouchLinePoint(xPosition, yPosition);
					break;
				case "touchmove":
				case "touchend":
					if(xPosition < 5 || 　xPosition > (canvas.width - 5) ||
						yPosition < 5 || 　yPosition > (canvas.height - 5)) {
						return;
					}
					if(linePointNum != -1) {
						linePoints[linePointNum].X = xPosition;
						linePoints[linePointNum].Y = yPosition;
					}
					context.clearRect(0, 0, canvas.width, canvas.height);
					drawIntrusion();
					break;
			}
		}

		function checkTouchLinePoint(X, Y) {
			if((Math.abs(X - linePoints[0].X) < 20) && (Math.abs(Y - linePoints[0].Y) < 20)) {
				linePointNum = 0;
			} else if((Math.abs(X - linePoints[1].X) < 20) && (Math.abs(Y - linePoints[1].Y) < 20)) {
				linePointNum = 1;
			} else if((Math.abs(X - linePoints[2].X) < 20) && (Math.abs(Y - linePoints[2].Y) < 20)) {
				linePointNum = 2;
			} else if((Math.abs(X - linePoints[3].X) < 20) && (Math.abs(Y - linePoints[3].Y) < 20)) {
				linePointNum = 3;
			} else if((Math.abs(X - linePoints[4].X) < 20) && (Math.abs(Y - linePoints[4].Y) < 20)) {
				linePointNum = 4;
			} else if((Math.abs(X - linePoints[5].X) < 20) && (Math.abs(Y - linePoints[5].Y) < 20)) {
				linePointNum = 5;
			} else {
				linePointNum = -1;
			}
		}

		/**
		 * 绘图保存
		 */
		function saveCommit() {
			var sendPoint = [];
			for(var i = 0; i < lineCfgInfo.PointNum; i++) {
				var point = {
					X: 0,
					Y: 0
				};
				point.X = Math.floor(linePoints[i].X * 10000 / canvas.width) == 10000 ? 9999 : Math.floor(linePoints[i].X * 10000 / canvas.width);
				point.Y = Math.floor(linePoints[i].Y * 10000 / canvas.height) == 10000 ? 9999 : Math.floor(linePoints[i].Y * 10000 / canvas.height);
				sendPoint.push(point);
			}
			GridService.LineInfoList[0].Enabled = lineCfgInfo.Enabled;
			GridService.LineInfoList[0].Direction = lineCfgInfo.Direction;
			GridService.LineInfoList[0].StartPoint = sendPoint[0];
			GridService.LineInfoList[0].EndPoint = sendPoint[1];
			dsBridgeFuncSyn.showLoading();
			SendAjax(LAPI.CrossLineAreas, 'put', function(code, data) {
				dsBridgeFuncSyn.dismiss();
				if(code == 0) {
					for(var j = 0; j < lineCfgInfo.PointNum; j++) {
						oriLinePoints[j].X = linePoints[j].X;
						oriLinePoints[j].Y = linePoints[j].Y;
					}
					var param = {
						CrossLineGrid_Bak: GridService
					}
					dsBridgeFuncSyn.sendDataToReport("updateCrossLineGrid", JSON.stringify(param));
					drawbtn.classList.add("ui-drawbtn-invisible");

					dsBridgeFuncAsyn.setScreenRotation("0", function() {
						showToast(langTip["WEB_logcat_save_successful"]);
						dsBridgeFuncSyn.backTo();
					});
				} else {
					showToast(langTip["WEB_toast_modify_favoritesname_failed"], code);
				}
			}, GridService);
		}
		//绘图相关工具条，按钮
		mui('#drawback').on('tap', 'button', function() {
			if(this.id == "goBack") {
				if(JSON.stringify(linePoints.slice(0, lineCfgInfo.PointNum)) ===
					JSON.stringify(oriLinePoints.slice(0, lineCfgInfo.PointNum)) && lineCfgInfo.Direction == CrossLineGridServiceObj.LineInfoList[0].Direction) {
					dsBridgeFuncAsyn.setScreenRotation("0", function() {
						dsBridgeFuncSyn.backTo();
					});
				} else {
					var btnArray = [langTip["WEB_cancel"], langTip["WEB_password_confirm_modify"]];
					var str = langTip["WEB_confirm_save"];
					if(str.indexOf("?") != -1) {
						str = str.substr(0, str.indexOf("?") + 1);
					}
					mui.confirm(str, langTip["WEB_dialog_title_notify"], btnArray, function(e) {
						if(e.index == 1) {
							saveCommit();
						} else {
							dsBridgeFuncAsyn.setScreenRotation("0", function() {
								drawbtn.classList.add("ui-drawbtn-invisible");
								dsBridgeFuncSyn.backTo();
							});
						}
					}, 'div');
				}
			}
		});
	</script>

</html>