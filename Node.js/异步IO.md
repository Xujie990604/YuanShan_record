# 异步模型

## 异步 I/O

* 基于事件驱动的非阻塞 I/O 架构(非阻塞 I/O 的设计使得 CPU 不必等待 I/O 的结果)
* Node 的单线程指的是 JS 的执行是单线程的， I/O 操作由单独的 I/O 线程控制
* Node 中的事件主要来自于 1. 文件 I/O 2. 网络 I/O

### 非 I/O 的异步 API

1. setTimeout()
2. process.nextTick() 回调函数存储在`数组`中，每次 `Tick` 过后会将数组中`所有的回调函数`执行完毕(类似于微任务)(process.nextTick() 中的回调函数执行的优先级要`高于` setImmediate())
3. setImmediate() 回调函数存储在`链表`中，每次 `Tick` 之后只会将链表中的`第一个`回调函数执行，然后等待下一轮(类似于宏任务)

## Node 的优点

* 处理多任务时无需创建新的线程或进程，上下文切换的代价小也不需要关注多线程带来的锁问题。
* 充分利用 CPU 资源，使得 CPU 无需等待 I/O 等耗时的操作。对于 I/O 密集型系统具有较高的性能。

## Node 的缺点

* 在面对大量的 CPU 计算时 Node 的计算能力并不差，主要的挑战在于长时间的运算会导致 CPU 时间片无法被释放，使得 Node 无法发起后续的 I/O 任务(情况类似于浏览器中 JS 长时间执行导致无法通知 UI 进行渲染)(解决方案：适当的将大任务进行拆分，使得运算能够及时释放，不长时间阻塞后续 I/O 任务调用(类似于浏览器中使用 setTimeout 拆分任务))

1. 无法利用多核 CPU
2. 错误会引起整个应用的退出
3. 大量计算占用 CPU 导致无法继续调用异步 I/0

## 异步编程

### 无法捕获回调函数中的异常

* Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出

### 函数嵌套层级太深

* 使用 async/await 来完美解决回调函数嵌套层级太深的问题

### 无多线程编程
