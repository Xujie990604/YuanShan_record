# 函数作用域(词法环境)

## 一、作用域

- 作用域：全局作用域、局部作用域(也称函数作用域、词法作用域)、块级作用域
- 作用域链([[scope]]属性仅供 JS 引擎读取): 代码执行流每进入一个新的上下文，都会创建一个作用域链，其中存储了`执行上下文`的集合。
- 作用域链: 本质上是一个指向 `执行上下文` 的 `指针列表` ，它只包含 `执行上下文的引用`。

## 二、执行上下文(简称上下文)

### 2.1 执行上下文定义

- 上下文分类：全局上下文、函数上下文、块级上下文
- 变量或者函数的上下文决定了它们能访问哪些数据，每个上下文中都有一个关联的 `变量对象`，变量对象中是它们能够访问到的所有变量和函数

### 2.2 以函数上下文为例来分析

### (1) 函数被定义时

1. 函数被定义时的作用域链中，有所处位置(代码书写层级)的执行上下文
2. 定义在父函数中的子函数，能通过`作用域链的形式`来访问父函数的执行上下文。父子函数访问的执行上下文引用地址一致，也就是数据公用，可以一起更改数据。(闭包产生的基础)

## (2) 函数被执行时

- 执行上下文: 当函数`执行`时，会创建一个称为执行上下文的对象(预编译产生)。当函数执行完毕时, 函数自己创建的执行上下文被销毁，但是函数的作用域链中仍保留所处位置的执行上下文
- 函数每次执行时对应的执行期上下文都是`独一无二`的，所以多次调用同一个函数会创建多个执行期上下文(这就是为什么函数多次调用时，前一次调用对函数内部值的修改，不会影响下一次函数的执行)

### 2.3 执行上下文的代码示例

```JS
function son () {}
```

- GO{} 是全局上下文，SO 是 son 函数上下文，FO 是 father 函数上下文

|                  |          作用域链          |
| :--------------: | :------------------------: |
| son 函数被定义时 |    [[scope]] --> [GO{}]    |
| son 函数被执行时 | [[scope]] --> [GO{}, SO{}] |

```js
function father() {
  function son() {}
}
```

|                     |             作用域链             |
| :-----------------: | :------------------------------: |
| father 函数被定义时 |       [[scope]] --> [GO{}]       |
|  son 函数被定义时   |    [[scope]] --> [GO{}, FO{}]    |
| father 函数被执行时 |    [[scope]] --> [GO{}, FO{}]    |
|  son 函数被执行时   | [[scope]] --> [GO{}, FO{}, SO{}] |

1. son 执行时，作用域链中的 `FO{}`。就是 father 函数被定义时，作用域链中的 `FO{}`
2. son 函数执行完毕后，会将 `SO{}` 销毁，下次再调用时重新创建新的 `SO{}`

> 理解以上两点，是搞懂 (1.闭包如何产生、2.函数每次调用，不受上一次函数调用时值的修改的影响) 这两个问题的关键

## 三、延长作用域链

1. with() 把指定的对象添加到作用域链的前端。`!不推荐使用`

```js
const temp = {
  name: "bar",
};
function test() {
  let name = "foo";
  with (temp) {
    console.log(name); // bar
  }
}
```

2. catch 语句，会把要抛出的错误对象添加到作用域链的前端

```js
try {
  let userInfo = {};
  let length = userInfo.name.length;
} catch (error) {
  console.log("err:", error.message);
}
```
