# 作用域(词法环境)

- 作用域：全局作用域和局部作用域(也称函数作用域，词法作用域)
- 作用域链: [[scope]]: 每个 javascript 函数都是一个对象，对象中的属性我们可以访问，但有些不可以，这些属性仅供 Javascript 引擎存取，[[scope]]就是其中一个，指的是我们所说的作用域链，其中存储了`执行期上下文`的集合。
- 作用域链: 本质上是一个指向`执行期上下文`的`指针列表`，它只包含引用不包含执行期上下文。

## 执行上下文(简称上下文)

- 每个执行上下文中都有一个关联的变量对象，变量对象中是所有能够访问到的变量和函数
- 函数被(定义)时的作用域是所处环境的执行期上下文
- 执行期上下文: 当函数(执行)时，会创建一个称为执行期上下文的对象(预编译产生)。一个执行期上下文定义了一个函数执行时的环境。当函数执行完毕时。函数预编译所产生的自己的执行期上下文被销毁。初始的所处环境的作用域链仍存在。
- 函数在哪里被定义和在哪里被执行时完成不同的概念(一个函数被定义在某个函数里面，就能得到父函数的执行期上下文，一个函数在另一个函数内被执行，只是被执行，得不到该函数的东西)。执行期上下文是一个对象，父子函数拿到的执行期上下文有相同的引用，也就是数据公用，可以一起更改数据。(闭包就是因为这个产生的)
- 函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文(函数多次调用，前一次调用对 h 函数内部值的修改，不会影响下一次函数的执行)

## 例子分析

```JS
function a () {

}
```

a 被定义时 a.[[scope]] --> 0 : GO {}

a 被执行时 a.[[scope]] --> 0 : AO {}
1 : GO {}

函数被定义时的作用域链是所处环境的执行期上下文
如果 function a() {} 里面有一个 function b() {}
则 b 刚刚被定义时继承 a 的作用域链 b.[[scope]] --> 0 : AO {}
1 : GO {}

- b 的作用域链中的 AO 就是 a 的作用域链中的 AO

1. b 的作用域链被销毁时只是把执行时创建的本身的 AO 销毁，被定义时继承的来自 a 的执行期上下文没有被销毁，等待下一次的执行。
2. a 的作用域链被销毁时也是把执行时创建的 AO 销毁，被定义时继承的 GO 没有被销毁，但是因为 b 函数定义在 a 函数里，所以 b 函数被销毁。
3. 只有自己创建的执行上下文被销毁，而所处环境的执行期上下文不被销毁是理解作用域链(闭包的产生，函数每次调用，不受上一次函数调用时值的修改的影响)的关键

## 延长作用域链的方法

1. with() 把指定的对象添加到作用域链的顶部。with 代码块内部获取变量时在新添加的作用域内查找，但是运算产生的新的变量会放到上一层的作用域中(不推荐使用)
2. 对于 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出错误对象的声明
