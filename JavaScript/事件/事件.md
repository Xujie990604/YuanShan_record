<!--
 * @Author: x09898 coder_xujie@163.com
 * @Date: 2022-05-09 20:54:21
 * @LastEditors: xujie 1607526161@qq.com
 * @LastEditTime: 2022-08-10 20:31:21
 * @FilePath: \HTML-CSS-Javascript-\JAVAScript+ES6\JavaScript\DOM\事件\事件.md
 * @Description: 
-->
# 事件

## 事件流

### 事件流的过程

* 个人理解 一个事件会触发一个事件流，事件流的过程需要访问好多的元素，执行涉及到的元素身上对应事件(比如是一个click事件的事件流那么事件过程中执行的就是click的事件处理函数)的事件处理函数。
* 先是从最大的范围进行捕获，为截获事件提供了机会，然后是处于**目标阶段**，然后是事件冒泡对事件进行响应。
* 在层级嵌套的DOM结构中， 一次点击事件(事件流), 会从顶部元素捕获到**目标元素**，等到达目标元素之后转化为冒泡阶段，从目标元素冒泡到顶部元素。

### 冒泡和捕获

#### 事件冒泡

* 结构上(非视觉上)嵌套关系的元素，会存在事件冒泡功能，即同一个事件，自子元素冒泡向父元素。(自底向上)

#### 事件捕获

* 结构上(非视觉上)嵌套的元素，会存在事件捕获的功能，即同一个事件，自父元素，捕获至子元素(事件源元素)(自顶向下)

* 一个对象的一个事件类型(的某一个函数)只能选择一种事件模型（冒泡或者捕获）
* 触发顺序：先捕获后冒泡。但是被点击的元素执行时，不是冒泡也不是捕获。他就是自己的事件执行。如果同时具有冒泡和捕获。按照绑定的顺序来执行。

* focus,blur,change,submit,reset,select等事件没有冒泡

#### 取消冒泡和捕获

* 事件对象上的取消冒泡方法 e.stopPropagation()
* 取消冒泡 类似于在该元素的上面设置一层屏障， father设置了取消冒泡的话，事件能冒泡到father，但是father上面的DOM都冒泡不到了。要是点击的目标是father的父级元素，不会受到father的取消冒泡的影响。屏障设置在我的下面，关我父辈什么事情。

## 性能的优化

### 事件委托

* 例如一个列表中，不给每一个li单独添加事件，而是直接给ul一个事件，根据event的target的属性来确定目标元素是谁，配合着事件的冒泡。(个人理解  元素的事件一直都有，只不过事件有没有对应的执行函数，决定这触发事件后有没有表现，比如事件委托中，li元素并没有定义事件处理函数，但是它依旧可以被点击，并且以li为目标节点触发事件流，并且在冒泡的过程中，触发了ul上定义的事件)
* 减少事件处理程序的定义

### 移出事件处理程序

* 使用innerHtml替换和删除元素时极有可能不会删除元素中带有的事件处理程序。
* 使用removeChild(),replaceChild()这种纯粹的DOM方法应该会删除带有的事件处理程序吧？
* 最好是在页面被卸载之前移出所有的事件处理程序。使用unload事件。

## 事件，事件处理程序

* 事件是指用户或者浏览器的动作比如click，load
* 响应某个事件的函数就叫做事件处理程序(事件侦听器) click事件的事件处理程序就是onclick

## 书写

* event = "javascript statement(s)"
* js的代码包含在一对引号当中。可以添加任意数量的js语句，只需要使用分号隔开。 onClick = "test();return false;"

## 事件处理程序的机制

* 一个元素的事件被触发时，就会执行相应的代码。这些代码可以返回值。如果返回true，认为事件被完成了，如果返回false，那么认为事件没有被完成。onClick = "test();return false;"通过这种形式可以用来阻止事件的默认行为。

### 阻止事件默认行为

* return false;  只有以句柄的方式定义才能取消
* event.preventDefault() w3c标准，IE9以下不兼容  
* event.returnValue = false;  兼容IE
* 取消a标签的默认事件，执行空的js代码 ```<a href="javascript:void(0)">demo</a> <a href="javascript:;">demo</a>```

## 页面加载完毕之后的事件

* window.onload只能添加一个函数，后添加的函数会覆盖前面添加的函数

## 事件处理函数的绑定

* onclick是句柄事件(DOM0级方法)。 只能每个事件绑定一个函数。
* Element.addEventListener(DOM2级方法)("事件类型 --> click"，处理函数，false)能给一个事件触发多个处理函数。一起触发，按照绑定顺序执行。传入true的时候在捕获阶段调用事件处理程序，传入false的时候在冒泡阶段调用事件处理程序。大多数情况下我们都是将事件处理程序添加到事件的冒泡阶段
* 用for循环绑定事件，容易出现闭包问题

## 解除事件函数

* ele.onclick = null/false;
* ele.removeEventListener(type,function,false)  function内使用另一个函数引用。不然清除的时候找不到。
