# JavaScript 中的数据类型

## 一、原始值和引用值

### 原始值

* 原始值: Number Boolean String undefined（未定义，未赋值）null（空值）Symbol
* 传递方式：`值传递`
* 在栈内存中`直接存放数据`
* 复制变量：开辟一个新的栈空间，将变量的值添加到新的栈空间中
* 修改变量：为变量开辟一个新的栈空间，并将新值添加到新的栈空间中

### 引用值

* 引用值: Arr Object Function
* 传递方式：`地址传递`
* 在栈内存中存放是`对象实际地址的引用`(引用地址指向堆), 对象本身存储在`堆`中
* 复制变量: 开辟一个新的栈空间，新的栈空间中存放的是对象在堆上的地址。

## typeof 操作符

* 因为 ECMAScript 的`类型系统`是松散的，所以需要一种鉴定手段来确定变量的数据类型
// TODO: ES6 中是不是有更合理的判断变量类型的语法，或者自己设计一个通用函数

### typeof 返回值(字符串类型)

1. number
2. string
3. boolean
4. undefined(变量未初始化、变量未定义 `!JS设计糟粕` 明明这两种情况是天差地别，但是返回值却一样)
5. symbol
6. object(数组、对象、null `null 是 Object 属于历史遗留问题`)
7. function(虽然函数也是对象，但是由于`函数的特殊性`，特意做了区分)

## JavaScript 的数据类型

* 六个基本数据类型：Number Boolean String undefined（未定义, 未赋值) null(占位置, 空值) Symbol
* 复杂数据类型: Object(数组，函数，对象)

### undefined

* `已声明但是未初始化`的变量默认为 undefined，
* 引入 undefined 是为了正式明确`空对象指针(null)`和`未经初始化的变量`的区别

### null（空对象指针）

* 定义一个将来要`保存对象值的变量`时，使用 null 来进行初始化
* undefined `派生`自 null。所以 undefined == null

### boolean

* 转换值为 false 的值: `false` `""` `0` `NAN` `undefined` `null`

### Number

#### IEEE 754格式(双精度值)

* 经典问题 `0.1 + 0.2 == 0.3 // false`
* 这不是JS独有的问题，采用该规范的语言都有这个问题。根本原因是`二进制存储小数`时的`精度缺失`问题
* 十进制转二进制：整数采用`除2取余`、小数采用`乘2取整`(二进制中，小数点后的每一位表示的是2的幂次方的倒数, 二进制小数 0.1 表示的是 1/2)

#### 数值范围

* 使用 64 位(8字节)来存储 Number 类型变量
* JS 中数值有一个最大和最小的区间。infinity 就是正无穷。
* 使用 isFinite() 函数来判断是否介于最大数值和最小数值区间内。超过范围的数值将无法参加下一次计算

#### NAN

* 不是数值, 用于表示`本来要返回数值`的操作数`并没有返回数值`的情况(而不是抛出错误)
* NAN 与任何数都不相等，包括自身、任何涉及到 NAN 的操作都会返回 NAN
* isNAN() 方法，用于判断数值是否为 NAN 类型(isNAN() 会先调用一次 Number())

### String

1. 字符串有转义字  符
2. ECMAScript 中的字符串是不可变的，要想改变字符串的值就要销毁原来的字符串，然后再用另一个新的字符串填充变量。
3. toString() 方法，undefined 和 null 没有这个方法(因为他们两个没有对应的包装类)
4. String() 任何数值类型的数据都能够转化为字符串

### object

* ECMAScript中的对象就是一组数据和功能的集合，可以通过 new 操作符来创建
* Object() 类型是所有他的实例的基础
* 由于 ECMAScript 并不定义 DOM, BOM 所以他们可能不会继承自 Object()