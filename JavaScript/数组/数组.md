# 数组

## 一、JavaScript 数组的特点

1. JS 里面的数组十分不严格，几乎不报错。数组是一种特殊的对象(`映射表`)。
2. 溢出读和溢出写(溢出写的话会重新定义数组的长度)都不会报错。数组中`未定义`、`溢出访问`的数据都是 `undefined`
3. 存储任意类型：由于 JavaScript 弱处理性语言，数组的每一项都可以是不同类型的数据
4. 动态大小：JavaScript 中的数组大小是可以动态调整的，可以随着数据的添加自动增长以容纳更多的数据

```js
// 1. 溢出读
const arr = [1, 2, 3];
arr[4]; // undefined

// 2. 溢出写
const arr = [1, 2, 3];
arr[4] = 5;
arr; // [1, 2, 3, undefined, 5]

// 3. 存储任意类型
const fuc = function () {
  return "hello";
};
const obj = {
  name: "foo",
  age: 18,
};
const arr = [1, "2", false, undefined, null, fuc, obj];
```

### 1.1 length 属性

- 数组的长度
- 不是只读的, 可以通过 length 属性重新定义数组的长度，

```js
// 1. 通过 length 缩短数组长度
const colors = ["green", "blue", "red"];
colors.length = 2;
colors; // ["green", "blue"]

// 2. 通过 length 扩充数组长度，数组中未定义的值都是 undefined。
const colors = ["green", "blue", "red"];
colors.length = 2;
colors; // ["green", "blue", "red", undefined]
```

## 二、数组的定义形式

### 2.1 数组字面量

```js
// 数组字面量定义
var arr = [3];
var color = ["green", "blue", "red"];
```

### 2.2 使用构造函数 `!不推荐使用`

```js
// 1. 创建初始长度为 3 的稀松数组(`!构造函数没办法生成仅单个数值的数组` `!JS糟粕之一`)
var arr = new Array(3); // [undefined, undefined, undefined]

// 2. 创建一个 colors 数组
var colors = new Array("green", "blue", "red"); // ['green', 'blue', 'red']
```

## 三、数组方法

### 3.1 生成数组的方法

### (1) Array.from

- 用于将两类对象转化为真正的数组 1.类数组 2. 任何可迭代(Iterable)的结构

```ts
// 1. arguments(属于类数组) 转化为数组
function add(num1, num2) {
  arguments; // { 0: 1, 1: 2, callee: add(num1, num2), ... }
  Array.from(arguments); // [1, 2]
}
add(1, 2);

// 2. Set(可迭代结构) 转化为数组
const set = new Set().add(1).add(2).add(3);
set; // Set(3) {1, 2, 3}
Array.from(set); // [1, 2, 3]

// 3. 进行数组的浅拷贝
const obj = {
  name: "foo",
};
const arr1 = [1, "2", obj];
const arr2 = Array.from([1, "2", obj]); // [1, "2", { name: 'foo' }]
arr2.name = "bar";
arr1[2].name; // bar
arr2[2].name; // bar

// 4. 使用第二个参数，增强新数组的值
const arr = [1, 2, 3];
Array.from(arr, (x) => x * 2); // [2, 4, 6]
```

### (2) Array.of

- 用于将一组值转化为数组(`!是为了弥补 Array() 构造函数的缺陷`)

|           参数           |               结果                |
| :----------------------: | :-------------------------------: |
|       new Array()        |                []                 |
|        Array.of()        |                []                 |
| new Array(3) `!注意结果` | [undefined, undefined, undefined] |
|       Array.of(3)        |                [3]                |
|   new Array(3, 11, 8)    |            [3, 11, 8]             |
|    Array.of(3, 11, 8)    |            [3, 11, 8]             |

### 3.1 检测数组

- 在只有一个全局环境下，完全可以使用 value instanceof Array ，但是有多个框架(全局环境)的话会存在多个版本的 Array 构造函数
- Array.isArray(value)用于检测某个值是不是真的是数组

### 3.2 改变数组的方法

1. push()可以接收任意数量的参数，把他们逐个添加到数组的末尾，返回修改之后数组的长度
2. pop()最后一位剪切，返回移出的项。
3. unshift()可以接收任意数量的参数，把他们逐个添加到数字的开端，返回修改之后的长度
4. shift()第一位剪切，返回移出的项
5. reverse()逆转 将数组的项逆转，返回值是排序后的数组
6. sort()给数组排序 但是 sort 是字符串比较不是我们想要的数字比较，所以需要我们自己来实现。 返回值是排序完的数组

- 必须写两个形参
- 看返回值 1. 返回值负数，前面的数在前面 2. 返回值为正数，后面的数在前面 3. 为 0 ，不动
  (传参时按照冒泡排序的方式传参)

```js
arr.sort(function (a, b) {
  if (a > b) {
    return 1;
  } else {
    //简化为 return a - b;升序
    return -1; //简化为 return b - a;降序
  }
});
```

7. splice()从第几位开始，截取多少的长度，在切口处添加新的数据。并且会把截取的数据(返回)出来。参数传负数是从倒数第几位开始切片。只填写一个参数就是从参数位直接截到最后一位。截取的话返回值是截取的数据，添加的话返回空的数组。

### 3.3 不改变数组的方法

1. arr.concat(arr1)拼接数组(参数除了数组之外也可以是数据)，生成一个新数组。不改变原数组 返回值是一个新的数组
2. slice()从该位开始截取，截取到该位(不包含最后一位，基数从 0 开始) 如果一个参数就是从该位开始截取，截取到最后一位。 返回值是一个新数组，参数是负数的话就是从倒数第几位开始(也可以是负值加上数组长度) 如果不加参数的话，返回值是数组的拷贝
3. join("")参数是什么，就按照什么来连接数组，并且返回字符串。没有参数的话，默认用逗号连接。""就是空字符串，不用任何东西连接。-

### 3.4 检测数组类型

- 在只有一个网页的情况下，可以使用 instanceof 判断是数组还是对象

```js
const colors = ["green", "blue", "red"];
colors instanceof Array; // true
```

- ES6 提供了 Array.isArray() 方法来判断一个值是否为数组

```js
// 1. 验证数组
const colors = ["green", "blue", "red"];
Array.isArray(colors); // true

// 2. 验证类数组
function add(a, b) {
  Array.isArray(arguments); // false
}
add(1, 2);
```

### 3.5 迭代器方法

```js
// 注意，这三个方法的返回值不是数组，而是迭代器
const colors = ["green", "blue", "red"];
Array.from(colors.keys()); // [0, 1, 2]
Array.from(colors.values()); // ["green", "blue", "red"]
Array.from(colors.entries()); // [[0, 'green'], [1, 'blue'], [2, 'red']]
```

### 3.6 数组填充方法

- fill 向已有数组中插入值

```js
// 指定填充值
const zeroes = [0, 0, 0, 0, 0];
zeroes.fill(6); // [6, 6, 6, 6, 6]

// 指定填充值 + 开始索引
const zeroes = [0, 0, 0, 0, 0];
zeroes.fill(6, 3); // [0, 0, 0, 6, 6]

// 指定填充值 + 开始索引 + 结束索引
const zeroes = [0, 0, 0, 0, 0];
zeroes.fill(6, 3, 4); // [0, 0, 0, 6, 0]

// 指定填充值 + 开始索引(支持负数)
const zeroes = [0, 0, 0, 0, 0];
zeroes.fill(6, -3); // [0, 0, 6, 6, 6]

// 结束索引超出数组真实长度，超过部分会自动忽略，不会改变原数组的长度
const zeroes = [0, 0, 0, 0, 0];
zeroes.fill(6, 3, 10);  // [0, 0, 0, 6, 6] 
```
