# 内存管理和垃圾回收

## 一、栈内存和堆内存

### 1.1 栈内存

* 栈数据结构: 后进先出
* JS 中栈内存：主要用于存储 `执行上下文`。包括函数调用的参数、局部变量、函数的执行环境
* 栈内存特点：栈内存是一段`连续的内存空间`、分配`相对固定大小`的内存空间、并由系统自动释放
* 栈内存的性能：栈内存的`访问`和`操作`速度都`非常快`
* 栈空间优化：通过`迭代`替代递归，或者使用`尾递归`优化 // TODO: 添加对应内容

### 1.2 堆内存

* JS 中堆内存：主要用于存储`复杂对象`
* 堆内存特点：堆内存是一大块内存空间、`动态分配`内存空间、内存空间`不连续`、不会自动释放空间
* 堆内存的性能：堆内存的访问速度较慢
* 闭包引用的变量：当一个局部变量被当前函数之外的其他函数所引用(也就是发生了逃逸），此时这个局部变量就`不能随着当前函数的返回而被回收`，那么这个变量就必须储存在堆内存中

## 二、内存管理的过程

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

在 C 等底层语言中，1，2，3都是明确的
在 JavaScript 等高级语言中，只有 2 是明确的。 1 (在声明变量时系统自动分配内存) 3 (系统使用垃圾回收算法来清除)

## 垃圾清除算法

### 引用计数垃圾回收

* 初级的垃圾收集算法。此算法把 "对象是否不再需要" 简化定义为 "对象有没有其他对象引用到它" 。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收
* 缺点就是无法解决循环引用问题

### 标记清除算法

* 这个算法把 "对象是否不再需要" 简化定义为 "对象是否可以获得" 。这个算法假定设置一个叫做根(root)的对象(在 Javascript 里，根是全局对象)。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象
* 缺点是那些无法从根对象查询到的对象都将被清除，但是场景很少
