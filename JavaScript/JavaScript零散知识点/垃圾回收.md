# 垃圾回收(GC)

## 一、栈内存和堆内存

### 1.1 栈内存

* 栈数据结构: 后进先出
* JS 中栈内存：主要用于存储 `执行上下文`。包括函数调用的参数、局部变量、函数的执行环境
* 栈内存特点：栈内存是一段`连续的内存空间`、分配`相对固定大小`的内存空间、并由系统自动释放
* 栈内存的性能：栈内存的`访问`和`操作`速度都`非常快`
* 栈空间优化：通过`迭代`替代递归，或者使用`尾递归`优化 // TODO: 添加对应内容

### 1.2 堆内存

* JS 中堆内存：主要用于存储`复杂对象`
* 堆内存特点：堆内存是一大块内存空间、`动态分配`内存空间、内存空间`不连续`、不会自动释放空间
* 堆内存的性能：堆内存的访问速度较慢
* 闭包引用的变量：当一个局部变量被当前函数之外的其他函数所引用(也就是发生了逃逸），此时这个局部变量就`不能随着当前函数的返回而被回收`，那么这个变量就必须储存在堆内存中

## 二、内存管理的过程

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

* 在 C 等底层语言中，1，2，3都是明确的
* 在 JavaScript 等高级语言中，只有 2 是明确的。 1 (在声明变量时系统自动分配内存) 3 (系统使用垃圾回收算法来清除)

## 三、垃圾清除算法

### 3.1 引用计数垃圾回收

* 初级的垃圾收集算法。此算法把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它` 。
* 如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收
* 缺点: 无法解决循环引用问题

### 3.2 标记清除算法

* 这个算法把 `对象是否不再需要` 简化定义为 `对象是否可以获得`。
* 这个算法假定设置一个叫做根(root)的对象(在 Javascript 里，根是 window)。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象…… 。垃圾回收器将找到所有`可以获得的对象`和收集所有`不能获得的对象`
* 缺点：那些无法从根对象查询到的对象都将被清除，但是场景很少

## 四、优化垃圾的性能

1. 垃圾回收程序会周期性运行，并且开始垃圾回收的时机是不可控的，垃圾回收会明显拖慢渲染速度和渲染帧率

* 为啥 C 语言不能有 GC
* 一次 GC 大概的时间是多少
* V8 使用的垃圾回收方式是哪种
  
### 4.1 如何配合 V8 来实现更好的 GC

#### 解除引用

1. 执行代码时只保留必要的数据，如果数据不再需要，那么把它设置为 `null`
2. 注意：解除引用并不会触发垃圾回收程序，只是确保变量能在下一次垃圾回收时被回收
3. 适用范围：适用于全局变量和全局变量的属性，因为局部变量的值会在超过作用域后被自动解除引用

#### 使用 const let

1. 因为这两个都是块级作用域，会让垃圾回收程序尽早的回收
  
#### 内存泄露

1. 少声明全局变量，因为除了页面被销毁或者手动设置为 null，全局变量都不会被垃圾回收程序回收
2. 闭包导致的内存泄露，闭包访问的变量也不会被垃圾回收程序回收