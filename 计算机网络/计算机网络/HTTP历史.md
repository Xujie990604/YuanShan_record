
# HTTP 历史

## HTTP 0.9

1. 协议规定由客户端发起请求，由服务端响应请求
2. 协议诞生之初的目的只是用来传输超文本内容 HTML, 因此仅支持 GET 请求
3. 因为仅用来传输 HTML, 所以没有多余的请求头。请求报文只有一行，响应报文只有一行
4. 以 ASCII 字符流编码的格式返回 HTML 文档
5. 服务端发送完响应就关闭 TCP 连接
6. 虽然设计理念简单，但是充分验证了 WEB 服务的可行性

## HTTP 1.0

1. 增加了 HEAD(查询资源可行性) POST 方法
2. 增加了响应状态码，标记可能的错误原因
3. 增加了 HTTP Header 的概念，让 HTTP 处理请求和响应更加灵活，传输的数据不再局限于文本
4. 缺点：一个 TCP 请求只能发送一个 HTTP 请求，引入了非标准字段 Connection: keep-alive 来达到复用 TCP 的目的
5. 核心改动：增加了 Header 的概念

## HTTP 1.1

1. 增加了 PUT， DELETE， OPTIONS, PATCH 等方法
2. 长连接: TCP 连接复用，即 TCP 不默认关闭，可以被多个请求复用
3. 管道机制：一个 TCP 连接可以同时发送多个请求(但是要求响应的顺序和请求的顺序必须一致)
4. 允许响应数据分块：利于传输大文件

### 缺点

1. 虽然通过长连接来实现 TCP 复用的机制，但是一个连接同一时刻只能处理一个请求。如果前面的请求没有完成，后面的请求会处于阻塞状态**队头阻塞**
2. 利用管道机制在一定程度上能缓解**队头阻塞**问题，但是管道要求响应顺序和请求顺序一致，如果前面的请求很耗费时间(处理大量图片)，即使后面的请求已经处理完成了，但是仍需要等待前面的结果有响应之后才能返回数据。
3. Header 中的内容过多导致协议开销大，没有对应的压缩传输优化方案

## HTTP2

1. 二进制协议：不再使用 ASCII 编码传输，改用二进制来传输，每个请求或者响应的数据包被称为**数据流**
2. 多路复用：废弃了 HTTP1.1 中的管道，在同一个 TCP 连接中可以同时发送多个请求，并且不用按照顺序处理响应，避免了队头阻塞问题(由于可以同时处理多个请求，因此相邻的两个数据流可能不属于同一个响应，因此给每个流添加唯一的编号 ID)
3. 请求优先级：允许指定请求的优先级，使得关键请求被优先响应(请求HTML 的优先级高，等网页显示出来之后在请求图片等文件)
4. 头部信息压缩：专用算法进行头部数据压缩，减少数据的传输量。对于一些固定的头部信息会通过客户端和服务端同时维护一张头部信息表，传输的时候只传输索引
5. 服务端主动推送：允许服务器主动向客户端发送数据(webSocket协议)

## HTTP3

1. HTTP 协议运行于 TCP 协议之上，TCP 协议也会发生丢包导致阻塞的问题，因此 HTTP3 构想使用 UDP 协议来传输 HTTP。
