<!--
 * @Author: xujie 1607526161@qq.com
 * @Date: 2022-04-22 13:11:00
 * @LastEditors: xujie 1607526161@qq.com
 * @LastEditTime: 2022-09-26 00:43:48
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style></style>
  </head>

  <body></body>
  <script>
    // 定义一个 dep 类，专门用来管理依赖
    class Dep {
      constructor() {
        this.subs = [];
      }
      // 在 dep 实例中添加一个依赖
      addSub(sub) {
        this.subs.push(sub);
      }
      // 在 dep 实例中移除一个依赖
      removeSub(sub) {
        remove(this.subs, sub);
      }
      // 在依赖添加之前进行一次判断，在依赖不为 undefined 时才会添加
      depend() {
        if (window.target) {
          this.addSub(window.target);
        }
      }
      // 循环触发 dep 实例中依赖的 update 方法
      notify() {
        // 返回数组的拷贝
        const subs = this.subs.slice();
        // 循环的触发所有依赖
        for (let index = 0; index < subs.length; index++) {
          subs[i].update();
          {
      }
    }

    const arrayProto = Array.prototype
    // arrayMethods 这个对象的原型上拥有和 Array 原型上一样的方法和属性
    // arrayMethods 对象是拦截器(在这个对象中的方法不仅能实现原有的功能，还能 发送变化通知)
    const arrayMethods = Object.create(arrayProto)
    ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method){
      // 缓存原始方法
      const original = arrayProto[method]
      Object.defineProperty(arrayMethods, methods, {
        value: function mutator(...args) {
          // 在拦截器中直接通过 this.__ob__ 来访问 value 上面的 Observer 实例
          const ob = this.__ob__
          // 在拦截器中，检测到数组发生变化时，就会通知依赖数据发生了变化
          ob.dep.notify()
          // 在调用 arrayMethods 对象中的方法时，实际上调用的还是 Array 原型上面的方法
          // 但是我们可以在这个函数中做一些其他事情，比如 发送变化通知
          return original.apply(this, args)
        },
        enumerable: false,
        writable: true,
        configurable: true
      })
    });

    // Observer 类会附加到每一个被侦测的 Array 上
    // 被侦测的 Array 会被替换原型上的方法，或者直接在自身上添加重写之后的方法
    class Observer {
      constructor(value) {
        this.value = value
        // Array 类型的数据，在 Observer 中存储依赖列表
        // 因为 Array 在 getter 中收集依赖，在拦截器中触发依赖，所以依赖要保存在一个双方都可以访问到的地方
        this.dep = new Dep()
        // 调用 def 函数用于在 value 上新增一个 __ob__ 属性，这个属性的值就是当前 Observer 实例
        def(value, '__ob__', this)
        // 只有当 value 的数据类型 Array 时,将上面的拦截器替换 Array 类型数据原有的原型
        // 如果浏览器不支持 __proto__ 的使用，直接粗暴的在 value 为 Array 类型的数值上逐个添加拦截器上的方法
        // (自己身上有的属性就不会去原型上面找，从而实现了方法的覆盖)
        if(Array.isArray(value)) {
          this.observerArray()
        }else{
          this.walk(value)
        }
      }
      // 工具函数，用于循环的将数组中的所有属性都变成响应式的
      observerArray(items) {
        for(let i = 0, L = items.length; i < L; i++){
          observe(items[i])
        }
    }
    }

    // def 工具函数，用于在 value 上添加 Observer 实例
    // 1. 添加完实例之后，在 getter 中可以通过 value.__ob__.dep 来访问 Observer 上面的 dep 
    // 2. 在拦截器中，可以通过 this.__ob__(在拦截器中 this 就是 value) 来访问 Observer 上面的 dep 
    function def(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !enumerable,
        writable: true,
        configurable: true
      })
    }

    // 通过 defineReactive 对数据进行响应式的处理(当前函数只考虑 Array 的场景)
    // Array 在 getter 中收集依赖， 在拦截器中触发依赖
    function defineReactive(obj, key, value) {
      // 通过 Observer 函数将 Array 数据类型的数据上的原生方法进行处理
      if(typeof(val === 'object')){
        new Observer(val)
      }
       let childOb = observe(val)
      // 每个 key 值对应的依赖，存储在 dep 实例中
      let dep = new Dep()
      Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
          // 收集依赖
          dep.depend()
          if(childOb) {
            childOb.dep.depend()
          }
          return val;
        },
        set: function() {
          // 如果改变过后的值和之前的值一样，则什么也不做
          // value 变量存储在 defineReactive 函数的作用域中 
          if(val === newVal){
            return
          }
          // 触发依赖
          dep.notify()
          val = newVal
        }
      })
    }
    // 尝试为 value 创建一个 Observer 实例
    // 如果 value 已经是响应式数据了，不需要再次创建一个新的 Observer 实例，直接返回已有的实例
    function observe(value, asRootData) {
      if(!isObject(value)){
        return
      }
      let ob
      if(hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__
      }else {
        ob = new Observer(value)
      }
      return ob
    }
    
  </script>
</html>
