<!--
 * @Author: xujie 1607526161@qq.com
 * @Date: 2022-04-22 13:11:00
 * @LastEditors: xujie 1607526161@qq.com
 * @LastEditTime: 2022-09-19 00:19:13
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style></style>
  </head>

  <body></body>
  <script>
    const arrayProto = Array.prototype
    // arrayMethods 这个对象的原型上拥有和 Array 原型上一样的方法和属性
    // arrayMethods 对象是拦截器(在这个对象中的方法不仅能实现原有的功能，还能 发送变化通知)
    export const arrayMethods = Object.create(arrayProto)
    ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method){
      // 缓存原始方法
      const original = arrayProto[method]
      Object.defineProperty(arrayMethods, methods, {
        value: function mutator(...args) {
          // 在调用 arrayMethods 对象中的方法时，实际上调用的还是 Array 原型上面的方法
          // 但是我们可以在这个函数中做一些其他事情，比如 发送变化通知
          return original.apply(this, args)
        },
        enumerable: false,
        writable: true,
        configurable: true
      })
    });

    // Observer 类会附加到每一个被侦测的 Object 上
    // 一但被附加上，Observer 会将 object 的所有属性转换为 getter/setter 的形式
    class Observer {
      constructor(value) {
        this.value = value
        // 只有当 value 的数据类型 Array 时,将上面的拦截器替换 Array 类型数据原有的原型
        // 如果浏览器不支持 __proto__ 的使用，直接粗暴的在 value 为 Array 类型的数值上逐个添加拦截器上的方法
        // (自己身上有的属性就不会去原型上面找，从而实现了方法的覆盖)
        if(Array.isArray(value)) {
          value.__proto__ = arrayMethods
        }
      }
    }
    
  </script>
</html>
