# 缓存

## webpack的缓存

* 为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。
* 不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制

## 浏览器的缓存

### Expires和Cache-Control字段

* Cache-Control的优先级高于Expires

* Expires是http1.0的字段

  1. 表示缓存的到期时间，是一个绝对的时间。
  2. 缺点就是写法复杂容易错误
  3. 可能由于时差等因素导致服务器和客户端时间不一致。出现问题。

* Cache-Control是HTTP1.1的字段

  1. public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  2. private：所有内容只有客户端可以缓存，Cache-Control的默认取值
  3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存(设置这个头部之后， 连内存缓存都不会有)
  5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效(使用的是相对时间)

### 内存缓存和硬盘缓存

内存缓存(from memory cache)

  1. 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
  2. 时效性：一旦该进程关闭，则该进程的内存则会清空。
  3. 先读内存，在读硬盘。内存的优先等级高。
  4. 浏览器会忽视例如 max-age=0, no-cache 等头部配置。因为内存缓存只是短期使用而已。max-age="0"的含义是，不要再下次浏览时使用。
  5. no-store。存在这个头部配置的话，即便是 memory cache 也不会存储
  6. 是浏览器的缓存行为, 一般不会受到开发者的HTTP协议的约束.

硬盘缓存(from disk cache)

  1. 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。
  2. 硬盘缓存会严格按照HTTP头部信息中的各类字段来判断哪些资源可以缓存。

在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)

### 强制缓存和协商缓存

* 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。
* 强制缓存优先于协商缓存，强制缓存由本地的缓存结果决定是否生效，协商缓存由服务器决定决定是否生效。
* 协商缓存就是强制缓存的后备的方案，一般来说在项目中，强制缓存和协商缓存一同出现。
* 协商缓存在请求次数上和没有缓存是一致的，但是协商缓存成功只返回一个状态码304。减少了响应报文的体积

强制缓存有关的字段是**Expires和Cache-Control**

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求
2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

协商缓存有关的是**Last-Modified / If-Modified-Since 和 Etag / If-None-Match**

  1. 携带缓存标识发起请求，如果资源没有更新，返回304，协商缓存生效
  2. 携带缓存标识发起请求， 资源有更新，返回200，协商缓存失效