# 模式和环境变量

- 可以通过指定不同的模式，来查看本地开发和生产环境生成的代码有哪些差异(打包时分别指定两种不同的模式，便能看到两种模式下的真实目录有什么差别)

## 一、模式(webpack 中的概念)

- 供 `mode` 配置选项，告知 `webpack` 使用`相应模式的内置优化`，默认值为 production，另外还有 development、none
- 如果 webpack 配置文件的导出内容为函数的话，函数的第二个参数的 mode 属性为　`模式`，便可以根据不同的模式来加载不同的 webpack `配置文件`
- 如果 mode 未通过配置或 CLI 赋值，CLI 将使用可能有效的 `NODE_ENV` 值作为 mode

### 模式的区别

1. development 开发模式：打包更加`快速`，省了代码优化步骤，不会删除未使用的变量或者文件，不会压缩文件，生成良好的source map, 有利于`开发中的调试`
2. production 生产模式: 打包比较慢，会删除未使用的变量或者文件，会开启 `tree-shaking` 和 `压缩代码`，减少体积，提升性能，适合发布到`生产环境`。
3. none: `不会应用任何默认优化`，输出的代码将保持原样，适用于`自定义`打包配置的特殊需求。

## 二、环境变量(node 中的概念)

- `process.env.NODE_ENV` 是在 `package.json` 的 `scripts` 命令中 通过 `cross-env` 插件来注入的, 也就是说 NODE_ENV 并不是 node 自带的，而是由用户显式定义的。
- 因为 NODE_ENV 属性是被注入到 `node` 的 process.env 中，所以只能在`工程文件中`使用该变量，WEB`业务代码`中是无法使用的。需要借用 `DefinePlugin` 插件将它注入到浏览器的全局变量中
- Webpack 项目不会自动根据`当前的环境变量`来加载`对应的环境变量文件`， 需要使用 `dotenv` 插件读取对应文件并将变量注入到 `process.env` 中，再使用 `DefinePlugin` 插件将变量注入到浏览器的全局变量中

## 三、Webpack 的执行环境

1. Webpack 在执行构建项目过程时，是处于 node 环境下，所以构建过程中执行的 JS 文件可以使用 node 相关内容(内置模块，全局对象，语法)
2. Webpack 在执行完构建项目动作后, 生成的 dist 文件是要被放到浏览器中识别，执行的。所以只能使用 node 的部分内容

### 3.1 dist 文件中包含 node 语法

1. commonjs: 可以使用，因为这只是个模块规范，webpack 可以把 require() 转换成在浏览器中合法执行的 JS 代码, 但是 require() 语句用来处理构建过程中的文件系统，如果需要在浏览器中进行文件操作，需要考虑使用 axios fetch 等语句
2. fs模块, path 模块： 不可以使用，浏览器中没有 fs path 模块 API，无法解析 fs path 语句
