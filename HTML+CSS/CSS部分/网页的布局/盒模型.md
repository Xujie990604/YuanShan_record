# 盒模型

## 标准盒模型

* box-sizing: content-box;标准盒模型
* width和height 只是content内容的大小
* 盒子的真实高度还要加上内边距和边框
* 内边距的作用是用来控制元素的大小，给元素应用的背景会被设置到content和padding中
* 外边距的作用是用来控制元素之间的距离。
* outline是用来调试用的，不会影响布局。

## 代替盒模型

* box-sizing:border-box;混杂盒模型
* width 和 height 包含了内容区，内边距和边框

## width的百分值继承

* 无论是标准盒模型还是怪异盒模型
* 盒模型中(无论是width height 还是 padding margin)使用百分数的时候，都是相对于真实的content区域的width和height大小。
* 如果在标准盒模型中就是width和height的大小，如果在怪异盒模型中，那就是width和height减去padding和border。

## 匿名盒子

```javascript
<div>
some text
<p>xujie</p>
</div>
```

* 尽管some text没有明确的被在某个元素里面，但是还是会生成一个匿名块盒子。
* 开发者无法通过css来控制他们，能继承的属性会从父元素继承，不能继承的属性是默认值。
* 关键是理解，(你在屏幕上看到的一切都会从属于某个盒子!!!!!!)。

## 外边距折叠

### margin合并

* 两个具有边距的元素上下相邻，两个盒子之间的边距大小是最大的那个单个边距大小。

### Margin collapsing(margin塌陷)

* 普通文档流中父子块级元素，如果父元素和子元素之间没有内边距和边框分割外边距(也就是说父子元素的外边距直接接触到了一起)，子元素的上边距就会和父元素的上边距重合，
* 以他们两个中间最大上边距为准，与距离他们最近的盒子隔开。
* 解决方式，父级元素触发bfc,父元素设置padding-top 或者 border-top

### 外边距折叠的理解

* 发生的条件

1. 外边距折叠只发生在文档的常规文本流中的块级盒子的垂直方向上，行内盒子，浮动盒子，绝对定位的盒子不会发生外边距折叠。
2. 只要是常规文档中的盒子，外边距直接接触了(不论是兄弟元素还是父子元素，甚至是自己的上边距和下边距直接接触)都会发生外边距折叠

* 外边距折叠的必要性

1. 因为外边距折叠的存在，无数的空段落也只会占用一小块的空间。

## 零散

* body有个默认的margin 8px
* 块盒的所有属性都受到尊重， 内联盒则不行(必须 display:inline-block)

## padding margin

* padding和margin使用百分比数值时，是基于包含块的宽度来计算，一般来说包含块就是父元素，也有例外。

1. margin为4个时，margin:上 右 下 左;（为顺时针方向）
2. margin为3个时，margin:上  左=右  下;
3. margin为2个时，margin:上=下  左=右;
4. margin为1个时，margin:上=右=下=左;

## 负边距

* 在文档流中，元素的最终边界是由margin来决定的，margin为负的时候相当于元素的边界往里面收。
* 设置负值的话,border以内的东西不会变小，元素的视觉效果还是那么大，只不过元素在文档流中的实际大小发生了变化。

* 左边或上边的负边距会把元素自身向左或者向上拉，盖住其旁边的元素。
* 右边或下边的负边距会把相邻元素向左或者向上拉，盖住设置了负边距的元素。
* (可视区域不会变).而与浮动方向相同的负边距会在该方向上把浮动的元素向外平移,自身覆盖其他元素。在浮动的元素上，与浮动方向相反的负边距会导致元素被其他元素覆盖。
* 给未声明宽度的(非浮动块级元素)使用负边距时，左右负边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。
