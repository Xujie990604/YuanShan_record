# Scss的语法

* Scss 是 Sass 引入的新语法，是 CSS3 语法的超集，与 CSS 完全兼容，并且继承了 Sass 的所有优点。

## 一、嵌套

* 属性和选择器的嵌套是非常伟大的特性

### 选择器嵌套

```scss
// 1. 单个选择器的嵌套
.main {
  // 用空格来拼接父元素和子元素
  .input {  // 编译成 .main .input
    ...
  }
  > p {   // 编译成 .main > p
    ... 
  }
  // & 会被 `父选择器` 直接替换
  &:hover {  //  编译成 .main:hover
    ...
  }
  &-header { //  编译成 .main-header
    ...
  }
  .logo & { // 编译成 .logo .main
    ...
  }
}

// 2. 群组选择器的嵌套
.container {
  h1, h2, h3 {margin-bottom: .8em}
}

// 编译成
.container h1, .container h2, .container h3 { margin-bottom: .8em }
```

### 属性嵌套

* 是为了便于管理这种同类属性，同时也是为了避免重复输入。

```scss
.main {
  font: {
    family: fantasy;   //编译为 font-family
    size: 20px;        //编译为 font-size
    weight: bold;      //编译为 font-weight
  }
}
```

## 二、变量

* 可以使用 `$xxx: yyy;` 的形式来定义变量
  
```scss
// 1. 变量作用域
$base-height: 100px;    // 普通变量的作用域为块级作用域。
.demo {
  $base: 200px !global; //通过 !global 声明全局变量
  width: $base;
  height: $base;
}

// 2. 变量值中引入其他变量
$border-color: red;
$border-size: 1px;
$border: $border-size solid $border-color;

```

## 三、导入

* CSS 的 `@import` 只有在执行到 `@import` 时浏览器才会去下载相关 CSS 文件，这导致了额外的网络请求。
* sass 的 `@import` 在 生成 CSS 文件时就会将相关 CSS 文件进行导入，避免了额外的下载请求.并且被导入文件的变量和 mixin 都可以在导入的文件中使用。

```scss
// 1. 局部文件：专门为 `@import` 命令而编写的文件, 并不需要生成对应的独立 CSS 文件
// 按照约定，这样的局部文件名以下划线(eg: _demo.scss)开头，这样 scss 就不会在编译时，单独编译这个文件，而只把这个文件作为导入
@import "demo"; // 引入时，可省略下划线，也可省略后缀

// 2. 默认变量值：在编写局部文件时，希望某个变量如果已经被声明过了，就用它声明的值，否则就用这个默认值
$border-color: red !default;

// 3. 嵌套导入：将一个局部文件中的内容仅导入到某个 CSS 规则内，并且局部文件中定义的变量、混合器都是只在当前规则中生效
// _demo1.scss 
$myself-color: red;
button {
  color: $myself-color;
}

// demo.scss
.name {
  @import './demo1.scss';
  background-color: $myself-color;
}

// 编译结果
.name {
  background-color: red;
}
.name button {
  color: red;
}
```

## 四、注释(静默注释)

```scss
// 这段注释不会出现在编译后的 CSS 文件中
/* 这段注释会出现在编译后的 CSS 文件中 */
```

## 五、@extend 继承

* 继承是基于类名的，所以继承应该是建立在语义化的关系上, 而不是样式的恰好相同
* `@extend` 背后最基本的想法是，如果 `.seriousError @extend .error`， 那么样式表中的任何一处 `.error` 都用 `.error.seriousError` 这一选择器组进行替换
* 继承的编译结果并不会复制更多的 CSS 属性，只是会复制更多的 CSS 选择器。所以多用继承能有效减少 CSS 代码体积

```scss
.error {
  font-size: 20px;
  color: red;
}

.serious-error {
  @extend .error;   // 编译之后会把 .error 的全部 css 属性引用过来。减少了重复代码的书写
  font-width: 500;
}

// NOTE: .serious-error 不仅会继承 .error 自身的所有样式，任何跟 .error有关的组合选择器样式也会被 .serious-error 以组合选择器的形式继承
header.error { 
  // NOTE: 编译会新增一个组合选择器 header.serious-error
  text-align: center
}
```

## 六、@mixin 混合器

* 继承的使用不够灵活，会将选择器内所有的CSS规则全部拿过来
* 混入中可以包含 CSS 和 SCSS 中有效的内容(变量定义， 控制指令)。然后我们就可以像定义一个多功能的函数一样来使用 混入

### 类名和混合器

* 类名：是在 HTML 中应用的，类名具有语义化含义，用来描述 HTML 元素的含义而不仅仅是外观
* 混合器：是在样式表中应用的，用来描述最终呈现的视觉效果。

```scss
// 1. 单一的混合器
@mixin white-card {
  height: 100px;
  width: 300px;
  background-color: #ffffff;
}

.device-card {
  @include white-card
}

// 2. 传参的混合器
// 默认值可以是任何有效的 CSS 属性值，甚至是其他参数
@mixin info-card($color: #ffffff, $width, $height: $width) {
  height: $height;
  width: $width;
  background-color: $color;
}

// 通过 $key: value 的形式传参，既结构清晰又不需要注意参数顺序
.device-card {
  @include info-card($width: 155px);
}
```

## 七、控制指令

### @if

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

### @for

* @for循环的是数字 使用变量的时候 $index 把整个变量放到括号里
* through表示范围包括1和5，使用to的时候表示范围包括1但是不包括5.

```css
@for $index from 1 to/through 5 {
  app-#{$index} {  //循环的变量用在选择器名称上时，使用#{$index}来拼接
      font-size: calc($index * 10px);  //在css属性中使用的时候直接使用$index
    }
}
```

### @each

* @each循环的是数组

```css
$list: xujie,xiaohan;
  @each $item in $list {
    .app-#{$item}{
      height: 20px;
    }
}
```
