# 事件

## 事件的前导

* 个人理解 一个事件会触发一个事件流，事件流的过程需要访问好多的元素，执行涉及到的元素身上对应事件(比如是一个click事件的事件流那么事件过程中执行的就是click的事件处理函数)的事件处理函数。

## 事件流

### 事件流的过程

* 先是从最大的范围进行捕获，为截获事件提供了机会，然后是处于**目标阶段**，然后是事件冒泡对事件进行响应。
* 在层级嵌套的DOM结构中， 一次点击事件(事件流), 会从顶部元素捕获到**目标元素**，等到达目标元素之后转化为冒泡阶段，从目标元素冒泡到顶部元素。
* 尽管DOM2事件规定捕获阶段不能涉及事件目标，但是现在的主流浏览器在捕获阶段都能涉及事件目标，可以在目标对象操作两次。

### 冒泡和捕获

#### 事件冒泡

* 结构上(非视觉上)嵌套关系的元素，会存在事件冒泡功能，即同一个事件，自子元素冒泡向父元素。(自底向上)

#### 事件捕获

* 结构上(非视觉上)嵌套的元素，会存在事件捕获的功能，即同一个事件，自父元素，捕获至子元素(事件源元素)(自顶向下)

一个对象的一个事件类型(的某一个函数)只能选择一种事件模型（冒泡或者捕获）
IE没有捕获ele.addEventListener(type,function,true);
触发顺序：先捕获后冒泡。但是被点击的元素执行时，不是冒泡也不是捕获。他就是自己的事件执行。如果同时具有冒泡和捕获。
按照绑定的顺序来执行。

* focus,blur,change,submit,reset,select等事件没有冒泡

#### 取消冒泡和捕获

* 事件对象 e.stopPropagation();IE9以下不兼容
* IE e.cancelBubble = true;
* 取消冒泡 类似于在该元素的上面设置一层屏障， father设置了取消冒泡的话，事件能冒泡到father，但是father上面的DOM都冒泡不到了。要是点击的目标是father的父级元素，不会受到father的取消冒泡的影响。屏障设置在我的下面，关我父辈什么事情。

## 性能的优化

### 事件委托

* 例如一个列表中，不给每一个li单独添加事件，而是直接给ul一个事件，根据event的target的属性来确定目标元素是谁，配合着事件的冒泡。(个人理解  元素的事件一直都有，只不过事件有没有对应的执行函数，决定这触发事件后有没有表现，比如事件委托中，li元素并没有定义事件处理函数，但是它依旧可以被点击，并且以li为目标节点触发事件流，并且在冒泡的过程中，触发了ul上定义的事件)
* 减少事件处理程序的定义

### 移出事件处理程序

* 使用innerHtml替换和删除元素时极有可能不会删除元素中带有的事件处理程序。
* 使用removeChild(),replaceChild()这种纯粹的DOM方法应该会删除带有的事件处理程序吧？
* 最好是在页面被卸载之前移出所有的事件处理程序。使用unload事件。
