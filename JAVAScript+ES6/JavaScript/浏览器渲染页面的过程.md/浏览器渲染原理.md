# 浏览器渲染原理

* 浏览器内核(Renderer进程)拿到内容之后，在自己的内部的线程内完成以下步骤。

1. 处理HTML生成DOM树(包括js动态生成的DOM节点)(深度优先原则)(DOM树的形成代表所有DOM节点的解析完毕而不是加载完毕 例如图片)
2. 处理CSS生成CSSDOM树
3. 将两树合并生成render树(display:none; 的DOM元素不在render树上，因为它不显示，也不影响布局。)
4. 对render树进行布局计算(回流每次布局阶段需要做的工作，当render树中的一部分因为元素的规模尺寸，布局，隐藏等改变需要重构时，也会回流)(也叫作重排)

* 在浏览器的Render进程中完成了render树的绘制之后，发给浏览器的GPU进程

1. 将render树中的每一个节点绘制到屏幕上(栅格化)

当render树中的属性需要改变是时，这些属性只是影响元素的外观，风格，而不会影响布局，称为重绘。
**重绘和重排会影响性能**

* 因为页面的js引擎线程和GUI线程是互斥的(不能一边改变DOM，一边绘制DOM)，所以重排和重绘的代价是昂贵的。

## 浏览器渲染页面耗时的主要四个点

1. 网络通信和HTML解析
2. javascript执行
3. 样式计算和布局，重排
4. 重绘

## 触发重排的方法

offsetTop() offsetLeft() scrollTop() scrollLeft() clientLeft() clientHeight() getComputedStyle() currentStyle()
这些属性虽然都是查看一些东西，但是浏览器为了保证数值的正确，会重新构建页面，然后返回最新的数值。
浏览器已经比较智能了，会攒几个(连续的)进行一起重排，重绘。(读(重排)操作放到一起，写(重绘)操作放到一起。优化方法)

## 浏览器的静默修复错误

* 如果错误的把应该显示在页面中的元素定义在了```<head>```标签中，浏览器会自动把页面元素放到body元素中。

## js中的全局对象

* 浏览器暴露给js引擎的全局对象是window。代表了一个页面的窗口。包含所有的全局对象，全局变量，和浏览器的API
* window的最重要的属性时document，它代表了当前页面的DOM。

## 浏览器加载时间线

1. 创建Document对象，开始解析web页面。这个阶段的document.readyState  = "loading".
2. 遇到link外部css，创建线程异步加载，并继续解析文档。
3. 遇到script外部js，并且没有设置async，defer，浏览器加载，并阻塞。等待js加载完成并执行该脚本，然后继续解析文档。

    js操作了尚未解析的dom，会怎麽办。找不到DOM，得到null

4. 遇到script外部js，并且设置async，defer，浏览器创建线程加载，并继续解析文档。
对async属性的脚本，脚本加载完之后立即执行。(异步加载禁止使用document.write(),当做文档流输出。会清除当前文档流，并且替换)
5. 遇到img标签的话，先正常解析dom（script也是Dom结构）结构，然后浏览器异步加载src，并继续解析文档。
6. 当文档解析(DomTree完成，但是img的图片不一定被加载出来，只是img的DOM被加载了)完成后，document.readyState = "interactive".
7. 当文档解析(DomTree完成)完成后，所有设置defer的脚本会按照顺序执行。
8. document对象触发DOMContentLoaded事件，这也标志着程序从同步脚本执行阶段，转化为事件驱动阶段。
9. 当所有async的脚本加载完成并执行后，img等加载完成后，document.readyState = "complete" ,window对象触发load事件
10. 从此之后，以异步响应的方式处理用户输入，网络事件等。

### load事件与DOMContentLoaded事件的先后

* DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。
* onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

### 注意文档的解析和加载两个状态

* 在DOM树形成之后叫做文档的解析完毕。解析完毕之后状态码改变。defer的脚本们按照顺序进行执行。
* 在img的src加载完之后和async的脚本下载并执行完之后，才能说文档被加载完了并且状态码改变。因为这两步都是异步操作。

## 文档解析被阻塞

* 无论是内联的还是外链的js的下载和执行都会阻碍后面DOM的解析和渲染(因为js会改变DOM，所以不能和文档的解析一起执行，否则会出现错乱)。除非是使用了defer和async属性
* css是由单独的下载线程异步下载的。对于一个html文档来说，不论是内联的还是外链的css，都会阻碍后续DOM的渲染，但是不会阻碍后续的DOM解析。所以优化时，避免无用的css文件。使用媒体查询只在必要的时候解析css文件。
