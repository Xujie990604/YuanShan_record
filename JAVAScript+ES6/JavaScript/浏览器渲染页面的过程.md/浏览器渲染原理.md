# 浏览器渲染原理

## Web 的执行分为两个阶段

1. 页面构建阶段(通过对 HTML 标签的解析，进行 DOM 的构建): 遇到 Script 标签(script 标签也是 HTML 标签的一种)时，执行标签中的 JavaScript 代码(1.JavaScript 代码通过浏览器暴露给JavaScript 引擎的全局对象: window 对象 来操作当前页面中的所有变量，浏览器 API 2.注册事件处理器)

2. 事件处理阶段: 按照事件的生成顺序，依赖事件队列来循环的处理事件。

### 不同环境下的顶层对象

1. ES5 之前，顶层对象的属性(window)和全局变量是等价的 (变量未声明就使用不报错)(window 对象是当前的浏览器窗口，是当前页面的顶层对象)
2. ES6 之后，var 和 function 声明的全局变量依旧是顶层对象(window窗口)的属性，let, const, class 声明的全局变量不再属于 window 对象(在控制台中查看时属于一个叫 script 的对象)

* window 对象会存在于整个页面的生存期之间

#### globalThis 对象(和宿主环境有关)

1. 浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有window。
2. 浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有self。
3. Node 里面，顶层对象是 global，但其他环境都不支持。

**ES2020在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。**

## 浏览器加载时间线

1. 创建 Document 对象，开始解析 web 页面。这个阶段的 document.readyState  = "loading".
2. 遇到 link 外部 css，创建线程异步加载，并继续解析文档。
3. 遇到 script 外部 js，并且没有设置 async，defer，浏览器下载 JS 文件，并阻塞后续 DOM 结点的解析。等待 JS 下载完成并执行完成该脚本后继续解析文档。
4. 遇到script外部js，并且设置async，defer，浏览器创建线程加载，并继续解析文档。
对async属性的脚本，脚本加载完之后立即执行。(异步加载禁止使用document.write(),当做文档流输出。会清除当前文档流，并且替换)
5. 遇到img标签的话，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档。
6. 当文档解析(DomTree完成，但是 img 的图片不一定被加载出来，只是 img 的 DOM 被加载了)完成后，document.readyState = "interactive".
7. 当文档解析(DomTree完成)完成后，所有设置 defer 的脚本会按照顺序执行。
8. document对象触发DOMContentLoaded事件，这也标志着程序从同步脚本执行阶段，转化为事件驱动阶段。
9. 当所有async的脚本加载完成并执行后，img等加载完成后，document.readyState = "complete" ,window对象触发load事件
10. 从此之后，以异步响应的方式处理用户输入，网络事件等。

### load 事件与 DOMContentLoaded 事件的先后

* DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。
* onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

### 注意文档的解析和加载两个状态

* 在 DOM 树形成之后叫做文档的解析完毕。解析完毕之后状态码改变。defer 的脚本们按照顺序进行执行。
* 在 img 的 src 加载完之后和 async 的脚本下载并执行完之后，才能说文档被加载完了并且状态码改变。因为这两步都是异步操作。

## 文档解析被阻塞

* 无论是内联的还是外链的 JS 的下载和执行都会阻碍后面 DOM 的解析和渲染(因为js会改变DOM，所以不能和文档的解析一起执行，否则会出现错乱)
* css 是由单独的下载线程异步下载的。对于一个 html文档来说，不论是内联的还是外链的 css，都会阻碍后续 DOM 的渲染，但是不会阻碍后续的 DOM 解析。(因为 renderTree = domTree + cssTree)
