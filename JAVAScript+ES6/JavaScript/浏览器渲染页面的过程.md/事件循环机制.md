# 事件循环机制

## Web的执行分为两个阶段

* 页面构建阶段，用于创建DOM。执行全局的js代码。注册时间处理器
* 事件处理阶段，按照事件的生成顺序，依赖事件队列来处理循环的处理事件。

## 事件队列

* 用户生成的事件和服务器生成的事件都会放置到事件队列中
* 一次只能处理一个事件
* 一个任务开始后直到运行完成， 不会被其他任务打断。
* 任务队列的添加和监测行为是独立事件循环的(任务的添加应该是由对应的工作线程完成， 网络工作线程， 事件线程， 定时器线程)

### 事件循环进阶，宏任务和微任务

* 事件循环的实现至少含有一个宏任务的队列和微任务的队列。
* 宏任务: 定时器任务， 网络任务， 鼠标事件， 键盘事件， HTML的解析(UI线程的渲染工作)， 执行全局的javascript代码
* 微任务： Promise的then()，catch()**promise.then() Promise.catch()才是真正的微任务，promise.resolve()只是Promise状态的改变，不是异步的**， DOM变化。
* 一次事件循环最多处理一次宏任务， 然后会处理微任务队列中的所有任务， 然后检查UI是否需要重新渲染。

* event loop的执行顺序

1. 一开始整个脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务(全局的js代码)执行完出队，检查微任务列表，有则全部执行完。
4. 然后检查下一轮宏任务，然后回到3，依次循环知道宏任务和微任务都为空

## 利用时间循环和setTimeout来优化高复杂度任务

* 只有每个宏任务被完成， 并且微任务也都被完成时， 才会进行UI的渲染
* 如果宏任务的处理事件太长， 就会导致页面卡顿。
* 可以利用setTimeout是个宏任务的特性， 把一个高复杂度的任务分解为几个宏任务。这样的话，在每个setTimeout执行完之后，都会有机会渲染UI界面。而不至于等待太长时间