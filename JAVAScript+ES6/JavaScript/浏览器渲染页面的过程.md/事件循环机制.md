# 事件循环机制、

## Web的执行分为两个阶段

* 页面构建阶段，用于创建DOM。执行全局的js代码。注册时间处理器
* 事件处理阶段，按照事件的生成顺序，依赖事件队列来处理循环的处理事件。

## 事件队列

* 用户生成的事件和服务器生成的事件都会放置到事件队列中
* 一次只能处理一个事件
* 一个任务开始后直到运行完成， 不会被其他任务打断。
* 任务队列的添加和监测行为是独立事件循环的(任务的添加应该是由对应的工作线程完成， 网络工作线程， 事件线程， 定时器线程)

### 事件循环进阶，宏任务和微任务

* 事件循环的实现至少含有一个宏任务的队列和微任务的队列。
* 宏任务: 定时器任务， 网络任务， 鼠标事件， 键盘事件， HTML的解析， 执行全局的javascript代码
* 微任务： Promise的then()，catch()**promise.then() Promise.catch()才是真正的微任务，promise.resolve()只是Promise状态的改变，不是异步的**， DOM变化。
* 一次事件循环最多处理一次宏任务， 然后会处理微任务队列中的所有任务， 然后检查UI是否需要重新渲染。

## 利用时间循环和setTimeout来优化高复杂度任务

* 只有每个宏任务被完成， 并且微任务也都被完成时， 才会进行UI的渲染
* 如果宏任务的处理事件太长， 就会导致页面卡顿。
* 可以利用setTimeout是个宏任务的特性， 把一个高复杂度的任务分解为几个宏任务。这样的话，在每个setTimeout执行完之后，都会有机会渲染UI界面。而不至于等待太长时间