<!--
 * @Author: xujie 1607526161@qq.com
 * @Date: 2022-04-22 13:10:58
 * @LastEditors: xujie 1607526161@qq.com
 * @FilePath: \HTML-CSS-Javascript-\JAVAScript+ES6\JavaScript\浏览器渲染页面的过程.md\事件循环机制.md
 * @Description: 
-->
# 事件循环机制

## 同步任务异步任务

### 同步任务

* 是指在主线程上进行的任务，只有前一个任务执行完毕的话，才能继续执行下一个任务。
* 如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。

### 异步任务

* 如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的
* 异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程

#### 异步的任务都有哪些

1. 网络请求事件
2. 浏览器的定时触发器
3. 浏览器的事件(load事件等),用户事件(鼠标事件，键盘事件等)

#### 消息队列和事件循环

* 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。
* 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。
* 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。
* Javascript主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。
* 消息队列中放的消息具体是什么东西: 消息就是注册异步任务时添加的回调函数(回调函数被封装为消息)

#### 异步任务的要素

* 从主线程的角度来看，一个异步过程需要两个要素 1.发起函数(异步函数， 异步任务的注册函数) 2.回调函数(要被放置到消息队列中的消息)
* 他们都是在主线程上被调用的，其中注册函数用于发起异步的过程(注册函数由主线程交付给对应的工作线程)。回调函数用于处理结果。(回调函数由工作线程交付给消息队列)

##### 异步任务的拆解

* 从异步过程的角度看；addEventListener函数就是异步过程的发起函数，事件处理器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，事件处理线程会将事件处理器函数封装成一条消息放到消息队列中，等待主线程执行。
* setTimeOut(() => {...},1000) 定时器任务中，setTimeOut函数是异步的发起函数，1000毫秒时间到了表示异步任务完成。定时器线程将 () => {...}回调函数放到消息队列中。等待主线程执行。
* 网络请求中：new Promise()是异步的发起函数，resolve()或者reject()执行代表异步任务完成，网络请求线程会将then() catch()的回调函数放入消息队列中，等待主线程的执行。
* 消息队列中 消息的添加和监测行为 是独立事件循环的(消息的添加应该是由对应的工作线程完成， 网络工作线程， 事件线程， 定时器线程)(例如一个1000的定时器，不是碰到定时器语句就给直接扔到宏任务队列里面了，而是由定时器线程监测这个定时器，等到1000毫秒之后，会把定时器中的回调函数放入宏任务中。因为是定时器线程进行的监测，JS执行线程并没有被占用，所以定时器下面的JS语句会被紧接着执行)

### 事件循环进阶，宏任务和微任务

* 事件循环的实现至少含有一个宏任务的队列和微任务的队列。
* 宏任务:(定义为独立的工作单元) 定时器任务， 网络任务， 鼠标事件， 键盘事件， HTML的解析(UI线程的渲染工作)， 执行全局的javascript代码
* 微任务：(更小的任务) Promise的then()，catch() Vue的nextTick()
* 一次事件循环最多处理一次宏任务， 然后会处理微任务队列中的所有任务， 然后检查UI是否需要重新渲染。

在宏任务基础上添加微任务队列的好处：添加微任务的好处就是能够让浏览器及时的处理宏任务中进行的DOM改动，假设没有微任务队列，如果浏览器中一次性添加了10个宏任务，这些宏任务中执行的对于DOM的操作都要等到10个宏任务全部执行完之后才能进行页面的更新，页面会显得十分卡顿，添加了微任务队列之后就可以使得宏任务对DOM进行改动之后，及时的在微任务中进行更新而不用等待所有宏任务都执行完成

* 事件循环的执行顺序

1. 一开始整个脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列(微任务中抛出来的微任务也会在下一轮的宏任务之前执行，只有微任务队列执行到当前微任务队列中没有任务了才会去执行下一个宏任务)
3. 当前宏任务(全局的js代码)执行完出队，检查微任务列表，有则全部执行完。
4. 微任务全部执行完之后进行一次UI的渲染
5. 然后检查下一轮宏任务，然后回到3，依次循环知道宏任务和微任务都为空

## 非常独特的计时器函数

### 利用时间循环和setTimeout来优化高复杂度任务

* 只有每个宏任务被完成， 并且微任务也都被完成时， 才会进行UI的渲染(因为任务中的代码可能会操作DOM，这个现象的本质就是JS代码执行阻塞页面的加载)
* 如果宏任务的处理事件太长， 就会导致页面卡顿。
* 可以利用setTimeout是个宏任务的特性， 把一个高复杂度的任务分解为几个宏任务。这样的话，在每个setTimeout执行完之后，都会有机会渲染UI界面。而不至于等待太长时间

### setTimeout而不是setInterval

* 当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中(我们只能控制定时器何时被添加到任务队列中，而无法控制何时执行)。所以时间上一般是不准的。
* 且setInterval有一些比较致命的问题就是。累计效应，如果setInterval代码在(setInterval)再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。(!!!由于JS引擎的优化，如果当前事件队列中有setInterval的回调没有被执行，正在等待状态，则不会重复添加回调函数 )
