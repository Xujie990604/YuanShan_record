# 克隆

* 深层克隆(克隆之后的对象或者数组的改变不会影响到被克隆的对象)。直接复制引用的的话，会把地址也拷贝过来。但是复制原始值得话，不会拷贝地址。所以一旦有引用值我就自己创建。引用值里面的原始值我才复制。
* 例如：Person{}我自己创建，但是Person.name我直接拿过来。

1. 判断是不是原始值(如果是原始值就直接进行赋值 target[prop] = origin[prop])
2. 判断是不是引用值(如果是引用值接着判断是数组还是对象)(然后建立对应的数组和对象)(然后把新建立的数组或者对象递归的调用)

```js
function deepClone (origin,target) {
    var target = target || {},  //如果没有传空对象的话，自动创建一个空对象
    tostr = Object.prototype.toString,
    arrStr = "[object Array]";

   <!-- for in 会遍历对象上的以及原型上的属性 -->
    for(var prop in origin) {
    // origin.hasOwnProperty(prop)如果prop属性在origin对象上而不是原型中，则会返回true
    // for in 和 hasOwnProperty 组合使用用来获取对象上的属性(不包含原型上面的)
        if(origin.hasOwnProperty(prop)) {
    //因为null,arr[],obj{}这三种数据的typeof都是"object"，所以在这一步需要排除一下null的影响 
            // 如果当前属性是引用值，进一步判断是数组还是对象。
            if(origin[prop] !== "null" && typeof(origin[prop]) == "object"){
                if(tostr.call(origin[prop]) == arrStr) {
                    // 如果是数组则建立新的数组
                    target[prop] = [];
                } else {
                    // 如果是对象则建立新的对象
                    target[prop] = {};
                }
                // 建立完数组或者对象之后，递归的调用本函数
                deepClone(origin[prop],target[prop]);
            }
            // 如果是基本数据类型直接赋值
            else {
                target[prop] = origin[prop];
            }
        }
    }
    return target;
}
```