# 函数对象

## 函数是对象

* 函数实际上是对象，每个函数都是Function类型的实例，而且和其他对象一样都具有属性和方法。
* 由于函数是个对象，因此函数名实际上也是一个指向函数对象的指针，不会与函数绑定。
* 函数是对象，函数名是指针。

## 没有重载

* 因为函数名只是一个指针，在想要进行函数重载时，两个同名的函数，相当于后面的函数覆盖了前面的函数体。

## 函数声明和函数表达式

* 函数声明有预编译(函数提升)，然而函数表达式的预编译过程只是把变量名提升，没有把函数体引用到变量上。

## 函数作为值使用

* 因为函数名本身就是变量，因此函数名可以当做值来使用。
* 要访问函数的指针而不是执行函数的话。只需要使用变量名，不需要使用执行符号(加了()是执行函数)
* 函数名加上()当做实参(a())传入参数时，函数接收到的是a函数的返回值。

## 两个函数会被默认拥有的参数

### arguments(类数组，函数内部的特殊对象)

* arguments是一个类数组对象，这个对象有一个callee的属性。该属性是个指针，指向拥有这个arguments对象的函数。
* 函数名只是一个变量，函数体是一个对象，在使用递归算法时，函数体内的代码执行与函数变量名耦合。为了解耦合使用arguments.callee来代替使用函数的变量名。

### this(函数内部的参数，指向的是函数执行的环境(对象))

* 将函数作为方法来调用对于实现js的面向对象编程至关重要， 可以通过this来引用方法的宿主对象。这是面向对象编程的基本概念。

## caller

* 这个属性中保留着调用当前函数的函数的引用(代码)，如果是在全局中调用这个函数会返回null，在其他函数中使用会返回父函数的代码。
* a函数在b函数中被调用，a.caller就是b函数

## 函数属性和方法

### 属性

* function.length 返回函数的形参个数
* prototype是ECMAScript的引用类型保存实例的真正所在，也就是说toString和valueOf方法都保留在prototype中。prototype是不可枚举的，不能使用for-in。

### 方法

* 每个函数都包括两个非继承过来的方法
* apply()和call()，在特定的作用域中调用函数，实际上等于设置函数体内的this值。
* call(obj，arguments...)必须明确的传入每一个参数,obj是重新指定的执行环境。
* apply(obj,[arguments])可以传入一个参数的数组，obj是重新指定的执行环境。
* 使用这两个方法来扩充作用域的好处是，对象不需要与方法有任何的耦合，函数就可以使用对象作为环境。
* ES5定义了bind方法，可以创建一个函数的实例。其this值会被绑定到传给bind()函数的值。 var b = a.bind(obj);

## 函数继承的方法

* toLocalString(),toString()方法始终都返回函数的代码，但是因浏览器而异。所以无法使用这两个方法实现重要的功能。
* valueOf()方法返回函数的代码