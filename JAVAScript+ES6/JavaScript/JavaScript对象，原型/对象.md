# 对象

* 引用类型的值(对象)是引用类型的一个实例，引用类型是一种数据结构(映射表)
* 对象: 一些属性和方法的集合

增： 直接用赋值语句进行增加
查： 直接访问属性(对象未定义的属性会输出undefined)
删： delete x.name 进行删除(用了 var 操作的属性，不可删除)
修： 直接用赋值语句进行修改

## 对象的创建方法

1. ```var obj = {}```    对象字面量创建方式
2. 构造函数

  1) 系统自带的构造函数 ```var obj = new Object();```
  2) 自定义

```JS
// 构造函数在命名时严格符合大驼峰式命名规则
function Person(height) {
  //var this = { 空对象，通过 this 加入属性和方法 }
  this.name = "xujie";
  this.health = height;
  this.run = function () {
    this.health --;
  }
  //return this; 将添加过属性，方法的对象返回出去
}
var person1 = new Person();
```

构造函数的内部原理(三段论)浅层次理解
  1）在函数体的最前面隐式的加上 this = {}
  2）执行 this.xxx = xxx;
  3）隐式的返回 this

* 如果构造函数内部显式的 return 一个对象， 那么通过 new 生成的(赋值给 this 的)对象将会被抛弃， 返回函数显式的定义的对象
* 如果构造函数内部显式的 return 一个非对象数值， 那么将会返回 new 生成(赋值给 this 的)对象， 构造函数内显式返回的非对象数值会被抛弃。

## 点操作符和方括号运算符

* 一般来说访问对象的属性都是使用点运算符，JavaScript 中可以使用方括号运算符来访问属性。
* 优点就是可以通过存储字符串的变量(如果使用变量的话不需要加引号，因为变量里面存储的数据就是字符串类型的)(或者字符串)来访问对象的属性。(终于找到了使用字符串访问函数的方法了)
* 如果属性名中包含会导致语法错误的字符，可以使用方括号来访问例如(obj["first name"]的赋值和访问)
* 而且可以因为 [] 内是字符串，那么就可以实现属性的拼接。

## 对象属性(特性)的类型

### 数据属性

* 直接通过对象字面量的方式创建的属性
* 必须通过 Object.defineProperty() 方法来指定某个对象的某个属性的特性的修改

#### 数据属性的特性

1. [[configurable]] 特性表示属性是否可以通过 delete 被删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为访问器属性。默认值为true
2. [[Enumberable]] 特性表示属性是否可以通过 for-in 进行循环返回，默认值为 true
3. [[Writeable]] 特性表示属性的值是否可以被修改，默认值为true
4. [[Value]] 特性代表属性实际的值，默认值为undefined

#### Object.defineProperty() 方法(在定义数据属性的情况下)

```js
// 使用 Object.defineProperty 可以修改上面的四个特性
// 调用 Object.defineProperty 方法时，没有明确生命的特性指为 false
// 调用 Object.defineProperty 方法，将 configurable 指定为 false 后，在想重新改为 true 会失败
const obj = {
  name: 'xujie'
}
// 三个参数： 1.对象 2.key值 3.配置对象
let a = Object.defineProperty(obj, 'age' , {
  configurable: true,
  enumerable: true,
  writable: true,
  value: '20'
})
```

### 访问器属性

* 访问器属性不能直接定义，只能通过 Object.defineProperty() 方法来定义

#### 访问器属性的特性

1. [[configurable]] 特性表示属性是否可以通过 delete 被删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为访问器属性。默认值为true
2. [[Enumberable]] 特性表示属性是否可以通过 for-in 进行循环返回，默认值为 true
3. [[Get]] 获取函数，默认值为 undefined
4. [[Set]] 设置函数，默认值为 undefined

#### Object.defineProperty() 方法(在定义访问器属性的情况下)

```js
const obj = {
  name: 'xujie'
}
 
let a = Object.defineProperty(obj, 'age' , {
  configurable: true,
  enumerable: true,
  get() {
    return this.age
  },
  set(newValue) {
    // 这是一种典型的用法。即设置属性时会导致其他属性的变化
    // 但是在 set 中不能改变 age 的值，否则会出现地递归栈调用溢出(因为只要修改 age 的值就会调用一次 set 函数)
    if(newValue > 18) {
      this.name = this.name + "成人"
    }
  }
})

```

## 对象的创建模式

### 工厂模式

* 使用一个函数封装起来创建对象和给队象赋值的语句。解决了创建多个相似对象的问题，但是没有解决对象的类型识别问题。

### 构造函数模式

* 创建对象时需要使用 new 操作符。
* 缺点就是在创建函数属性的时候，由于函数是一个对象。所以每一个实例都会有一个函数，他们完成的是相同的事情，所以没有必要。

### 原型模式

* 我们创建的每一个函数都有一个原型属性(prototype)，这个属性是一个指针，指向一个对象。(prototype)就是通过构造函数创建的那些实例的原型对象。所有的对象实例都可以共享原型对象中的属性和方法。
* 所有的对象实例共用的是同一个函数。
* 每个函数在创建时都有一个 prototype 属性，指向原型对象，原型对象上会自动获得一个constructor属性，这个属性指向prototype属性所在的函数。
* 调用构造函数创建的新的实例，实例的内部包含一个指针(__proto__)，指向构造函数的原型对象。这个连接是在实例与构造函数的原型对象之间，不是实例与构造函数之间。

#### 原型有关的方法

* Object.getPrototype() 来获取对象的原型。返回的是原型对象，可以用这个来访问原型上的属性。
* hasOwnPrototype() 方法用于检测属性是存在实例中还是原型中。在实例中会返回true。
* Object.getOwnPrototypeNames()，无论是否可枚举都可以通过这个方法来访问实例上的属性，不包括原型上的，返回是一个数组。
* for in 循环 返回的是所有能够通过对象访问的，可枚举的属性。既包括实例中的属性，也包括原型(但是不会打印最顶端Object原型上的属性)中的属性。
* in 操作符会在通过对象能够访问指定属性时返回 true。无论存在实例中还是原型中。
* Object.keys()方法，用于得到对象上所有的可枚举的实例属性。不包括原型上的，返回值是一个数组。

#### 原型模式的缺点

* 没有构造函数的传递参数这一个环节，所有的实例取得的都是相同的属性。
* 所有的实例的属性都是共享的。对于那些引用类型的属性来说，是不方便的，其中一个实例的修改，会牵扯到所有的实例。
