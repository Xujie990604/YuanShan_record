# 对象

* 引用类型的值(对象)是引用类型的一个实例，引用类型是一种数据结构

对象:一些属性和方法的集合

增： 直接用赋值语句进行增加
查： 直接访问属性
删： delete x.name进行删除(用了var操作的属性，不可删除)
修： 直接用赋值语句进行修改

对象未定义的属性会输出undefined

## 对象的创建方法

1. var obj = {}    对象字面量创建方式
2. 构造函数
    1)系统自带的构造函数 var obj = new Object();
    2)自定义

    构造函数在命名时严格符合大驼峰式命名规则
    function Person(height) {
        //var this = {
            空对象，通过this加入
        }
        this.name = "xujie";
        this.health = height;
        this.run = function () {
            this.health --;
        }
        //return this;
    }
    var person1 = new Person();

    构造函数的内部原理(三段论)浅层次理解
    1）在函数体的最前面隐式的加上this={}
    2）执行 this.xxx = xxx;
    3）隐式的返回this

* 如果构造函数内部显式的return一个对象， 那么通过new生成的(赋值给this的)对象将会被抛弃， 返回函数显式的定义的对象
* 如果构造函数内部显式的return一个非对象数值， 那么将会返回new生成(赋值给this的)对象， 构造函数内显式返回的非对象数值会被抛弃。

## 点操作符和方括号运算符

* 一般来说访问对象的属性都是使用点运算符，javascript中可以使用方括号运算符来访问属性。
* 优点就是可以通过存储字符串的变量(如果使用变量的话不需要加引号，因为变量里面存储的数据就是字符串类型的)(或者字符串)来访问对象的属性。(终于找到了使用字符串访问函数的方法了)
* 如果属性名中包含会导致语法错误的字符，可以使用方括号来访问例如(obj["first name"]的赋值和访问)
* 而且可以因为[]内是字符串，那么就可以实现属性的拼接。

## 对象属性(特性)的类型 p139 高程

### 数据属性

* 直接通过对象字面量的方式创建的属性
* 可以通过Object.defineProperty()方法来指定某个对象的某个属性来修改一些特性(权限)

### 访问器属性

* 访问器属性不能直接定义，只能通过Object.defineProperty()方法来定义
* 和数据类型类似，不过可以指定某个对象的某个属性的getter和setter函数。也是通过Object.defineProperty()方法定义
* get和set函数和Vue的计算属性类似

### 定义多个属性和读取属性的特征

* Object.defineProperties()支持同时定义某个对象的多个属性的特性
* 可以通过Object.getOwnPropertyDescriptor()方法来访问某个对象的某个属性的特性。返回值是一个对象。在javascript中可以针对任何对象，包括DOM和BOM对象进行访问。

## 对象的创建模式

### 工厂模式

* 使用一个函数封装起来创建对象和给队象赋值的语句。解决了创建多个相似对象的问题，但是没有解决对象的类型识别问题。

### 构造函数模式

* 创建对象时需要使用new 操作符。
* 创建一个新对象
* 将构造函数的作用域赋值给新对象(因此this指向这个新对象)
* 执行构造函数中的代码
* 返回新对象
* 缺点就是在创建函数属性的时候，由于函数是一个对象。所以每一个实例都会有一个函数，他们完成的是相同的事情，所以没有必要。

### 原型模式

* 我们创建的每一个函数都有一个原型属性(prototype)，这个属性是一个指针，指向一个对象。(prototype)就是通过构造函数创建的那些实例的原型对象。所有的对象实例都可以共享原型对象中的属性和方法。
* 所有的对象实例共用的是同一个函数。
* 每个函数在创建时都有一个prototype属性，指向原型对象，原型对象上会自动获得一个constructor属性，这个属性指向prototype属性所在的函数。
* 调用构造函数创建的新的实例，实例的内部包含一个指针(__proto__)，指向构造函数的原型对象。这个连接是在实例与构造函数的原型对象之间，不是实例与构造函数之间。

#### 原型有关的方法

* Object.getPrototype()来获取对象的原型。返回的是原型对象，可以用这个来访问原型上的属性。
* hasOwnPrototype()方法用于检测属性是存在实例中还是原型中。在实例中会返回true。
* Object.getOwnPrototypeNames()，无论是否可枚举都可以通过这个方法来访问实例上的属性，不包括原型上的，返回是一个数组。
* for in 循环 返回的是所有能够通过对象访问的，可枚举的属性。既包括实例中的属性，也包括原型(但是不会打印最顶端Object原型上的属性)中的属性。
* in 操作符会在通过对象能够访问指定属性时返回true。无论存在实例中还是原型中。
* Object.keys()方法，用于得到对象上所有的可枚举的实例属性。不包括原型上的，返回值是一个数组。

#### 访问实例中的属性

* 在实例中没有找到到指定的属性，就会去实例的原型上找属性。实例中的属性会屏蔽原型上的属性。
* 使用delete操作符可以删除实例上的属性，从而重新访问原型上的属性。

#### 原型赋值方式

* 如果是一条一条的给原型对象上添加值，原型对象的constructor属性指向构造函数，要是直接重写构造函数的原型对象(使用对象字面量的形式)，constructor不在指向构造函数，开始指向Object。(第一种方式的原型对象在构造函数中被构造，第二种方式的原型对象在Object中被构造)(constructor是被自动创建的，它的含义就是当前对象是被谁构造的)
* 使用instanceof仍可以正确识别对象的类型，在第二种方式中使用constructor无法正确识别对象的类型了。

#### 原型的动态性

* 为原型上添加属性，会立刻反映到所有的实例上，因为他们的指针都指向同一个原型对象。
* 但是重写原型对象就不一样了。构造函数的指针就会断了与最初原型对象的引用。在重写之前的实例保留的旧的原型对象，重写之后的实例与新的原型对象建立连接(主要：引用类型数据的数据结构，实例中的指针指向原型，而不是构造函数)

#### 原生对象的原型

* 原型很重要，就连原生的引用类型，都是采用的这种模式(Array,Object,String)
* 但是不推荐在原生对象的原型中随意添加方法。

#### 原型模式的缺点

* 没有构造函数的传递参数这一个环节，所有的实例取得的都是相同的属性。
* 所有的实例的属性都是共享的。对于那些引用类型的属性来说，是不方便的，其中一个实例的修改，会牵扯到所有的实例。

### 构造函数模式和原型模式的结合

* 实例的一些属性由构造函数来定义，方法和共享的属性用原型模式来定义
* 每个实例都会有自己到的实例属性，一个实例的修改不会影响其他实例(还可以初始化参数赋值)，所有的实例共享对于原型上方法的引用，最大限度的节省了内存。

### 动态原型模式

* 属性像构造函数一样定义，原型中需要的方法，可以通过判断语句来动态添加。

### 寄生构造函数模式

* p160 高程

### 稳妥构造函数模式

* 没有this和new，除了对象的方法能访问属性之外，没有 其他把办法可以访问到构造函数中的原始数据。