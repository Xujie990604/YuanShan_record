# 类型的转换(JS 的糟粕精髓所在)

* JS 中乱七八糟的隐式类型转换在日常的开发中需要尽量去避免
* 使用 === !== 强等于操作符来代替 == !=, 减少隐式类型转换的发生

## 显示类型转换

### Number() 可以用于任何类型

* Number() 尝试着将任何数据类型转换为数字类型  (能转化为数字就转化为数字，无法转化为数字就转化为 NAN)(没有砍断原则)

1. Number(123)           -> 123
2. Number("123")         -> 123
3. Number("12345a")      -> NAN
4. Number("a")           -> NAN
5. Number(true)          -> 1
6. Number(null)          -> 0
7. Number(undefined)     -> NAN
8. Number([123])         -> 123
9. Number([123, 2334])   -> NAN
10. Number([])           -> 0
11. Number("")           -> 0

* obj，function，NAN，undefined 转化完之后是 NAN

复杂类型隐式转化:

1. 先用 valueOf() 方法获取其原始值。如果原始值不是 Number 类型，则使用 toString() 转换成 String。
2. 再将 String 转换为 number 运算。

* 字符串的 number() 转化

1. 如果只包含数字，那么转化为 10 进制数值，会忽略前导零。
2. 字符串中包含有效的浮点格式，就转化为浮点数
3. 如果是十六进制，就转化为 10 进制
4. 如果字符串是空的就转化为零。
5. 其他格式全部转化为 NAN

### parseInt(string, radix) 用于把字符串转化为整形数值

1. parseInt() 转换时，更多的是看是否符合**数值模式**，会忽略字符串前面的空格，直至找到第一个非空格字符
2. 如果第一个不是数字字符或者负号，就会返回 NAN。比如 "" 空字符串返回 NAN，22.5返回 22 因为 . 不是有效数字字符
3. parseInt() 有一个 砍断原则 从数据首位开始看一直到非数字类型截止 例如 100px 转换之后变成 100
4. 不指定进制的话，意味着让引擎自己决定按照哪种进制解析字符串，所以无论什么情况都要指定进制 (基底是 0 的话，有的浏览器会直接输出原始值，或者 NAN。如果出现了不属于该进制的输的话，输出 NAN。 例如: 以二进制为基底的8)

### parseFloat(string) 用于把字符串转化为浮点数值

1. parseFloat(string)返回一个浮点数。有一个 砍断原则 从数据首位开始看一直到非数字类型截止
2. 只会识别一个小数点，22.45.21返回22.45

### string()

* string(par)把数据类型转换为字符串类型

### xxx.toString()

* xxx.toString() !!! undefined 和 null 不能用toString()
* num.toString(redix) 把 num 转换为 redix 进制的数字

### Boolean()

Boolean() 除了那六种数据其他都转换为 true 只有 undefended null NaN "" 0 false 这六个字符转化为布尔值类型为false

## 隐式类型转换

1. isNAN("num") 包含一个隐含的过程 先进行 Number(num) 操作然后再 isNAN(Number(num));

2. ++/--(自增自减运算符)    +/-(一元正负) 都会调用 Number()
 -*/% 都会调用 Number（）

3. && || 与或在决定返回值时是看表达式的布尔值为真或者为假 逻辑非 !(转换为布尔类型，在取反)

4. < > <= >= 有数字相比较的就会隐式转换为数字

5. ```+``` 当加号两端有一个 string 类型数字时，就会调用 String()

6. == != 有隐式类型转换

7. 不发生类型转换的 ===  !==

隐式转换规则:

1. 转成 String 类型。  + (字符串连接符)
2. 转成 number 类型。  ++/--(自增自减运算符) + - * / %(算数运算符) > < >= <= == != (关系运算符)
3. 转化为布尔类型。 ！(逻辑非运算符)
4. 不发生类型转换。 ===  !==

## 对象的隐式类型转换

复杂数据类型会先隐式转换为 String, 然后在转变为 Number。
复杂类型隐式转化：

1. 先用 valueOf() 方法获取其原始值。如果原始值不是 Number 类型，则使用 toString() 转换成 String。
2. 再将 String 转换为 number 运算。

空数组的 toString() 方法会得到空字符串。
空对象的 toString() 方法会得到字符串[object,Object]

[] == 0    //true
[].valueOf().toString() 得到空字符串
Number("") == 0 成立

![] == 0  //true
逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false
Number(false) == 0 成立

[] == ![]  //true
[].valueOf().toString() 得到空字符串
逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false
Number("") == Number(false)  成立

{} == !{}  //false
{}.valueOf().toString() 得到字符串[object,Object]
!{} 先把表达式转换为布尔值在取反。{} 不在那六种转换完为假的数据类型中。所以转换后为false
Number([object,Object]) == Number(false)  不成立

[] == [] //false
{} == {} //false
引用数据存储在堆里，比较的是地址。所以不成立。
