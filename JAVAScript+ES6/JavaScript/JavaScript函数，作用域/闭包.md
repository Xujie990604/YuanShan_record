# 闭包

闭包: 当内部函数被保存到外部时(使用return返回一个函数， 使用外部的变量接受函数， 使用构造函数return一个对象，对象的方法是个函数)，将会生成闭包，闭包会导致原有的作用域链不释放，造成内存泄漏(内存占用，剩的空间变少)。
闭包会一直持有父函数的执行期上下文(活动对象)，导致占用内存不被清除，造成内存泄露。有必要的话把在父函数末尾把一些对象设置为null，这样有利于回收机制回收内存。
被保存到外部的这个函数，自己预编译产生的执行上下文每次在执行自己时会重新创建一个新的，所以自己执行期上下文里面的变量不会受到
上次调用的影响，但是自己父级的执行期上下文一直保留没有被释放，导致每次重复执行函数时，父级的变量会受上次调用的影响。

## 闭包的应用

1. 实现公有变量    不依赖外部变量，而且能反复执行的累加器
2. 可以做缓存（存储结构） 相当于一个仓库(父函数返回多个子函数，这些子函数都会操作一个共同的变量)
3. 可以实现封装，属性私有化(高程的p186私有变量要去看看)
    因为闭包的存在，在(构造函数)里面var一个属性。其中有很多方法使用到了这个属性。
    构造结束后，构造函数释放函数作用域，通过函数不能再直接访问到这个属性。
    但是由于构造函数隐式的返回this(this就是一个对象实例)。而this中有很多方法使用了这个属性。还保留着对于这个属性的应用。
    所以可以通过方法来访问这个属性。(类似于java中的私有变量)

```js
function Xu() {
        let counter = 0;
        this.add = function() {
            counter++;
        }
        this.getCounter = function() {
            return counter;
        }
 }
 const xujie = new Xu();
 let a = xujie.getCounter() //0
 xujie.add()
 let b = xujie.getCounter()//1
```

4. 模块化开发，防止污染全局变量

```javascript
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function () {
            document.write(i +" ");
        }
    }
    return arr;
}

var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
}
```

输出结果：10 10 10 10 10 10 10 10 10 10

解析：这是一个闭包的问题 函数test内包含一个for循环，每个循环里都有一个函数表达式的赋值。
相当于是一个一对十的闭包。里面的十个函数表达式共用一个变量i。

```javascript
arr[i] = function () {
            document.write(i +" ");
        }
```

函数定义的时候并不会被执行，比如这些代码的含义相当于
        arr[i] = 一个函数体
但是函数体重的变量i是多少系统也并不知道。只有当这个函数执行之后才会知道函数中的变量i是多少。
也就是说等 ```myArr[j]();```这条语句执行完之后才会知道函数中的变量i是多少。
因为for循环所以function test内的变量i累加到了10，才终止循环。
test函数执行完后，切断了test的执行期上下文，但是由于闭包的存在十个小函数依然保留着与test函数的执行期上下文的联系
因此等到十个内部函数执行时，每个函数都会读取出最后为10的i变量。

！！！解决方法 用闭包解决闭包问题 让一对十的闭包问题，转化为十对十的闭包问题。
原来是十个子函数对应着一个主函数。公用一个i变量。
现在使用了立即执行函数(或者是只使用一个let也可以实现)。是每个孙函数都对应一个子函数(立即执行函数)
实现的一个重点就是函数是按值传递的，闭包的产生是因为好多函数都带有对同一个变量的引用，使用立即执行函数之后，按值传递。
每个新加的立即执行函数对应着一个新的变量。

```javascript
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
       (function(j){
            arr[j] = function () {
            document.write(j +" ");
        }
       }(i))
    }
    return arr;
}

var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
}
```

逗号运算符
(a,b)先运算前面的表达式，然后运算后面的表达式。最后输出后面的表达式

var x = 1;
if(function f() {}) {
    x += typeof f;
}
console.log(x);
输出：1undefined

if后面的()把里面的函数声明变成了表达式。因为函数声明不是那六个转换之后为false其中之一，所以if后面的语句可以执行。
并且函数名称f消失。typeof(f)为"undefined"
x += typeof f    1 + "undefined"   结果为 1undefined
