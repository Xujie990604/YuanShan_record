# 闭包

* 闭包: 当内部函数被保存到外部时(1.使用return返回一个函数， 使用外部的变量接受函数。 2.使用构造函数return一个对象，对象的方法是个函数)，将会生成闭包，闭包会导致原有的作用域链不释放，造成内存泄漏(内存占用，剩的空间变少)。
* 被保存到外部的这个函数，自己预编译产生的执行上下文每次在执行自己时会重新创建一个新的，所以自己执行期上下文里面的变量不会受到上次调用的影响，但是自己父级的执行期上下文一直保留没有被释放，导致每次重复执行函数时，父级的变量会受上次调用的影响。
* 闭包会一直持有父函数的执行期上下文(活动对象)，导致占用内存不被清除，造成内存泄露。有必要的话把在父函数末尾把一些对象设置为null，这样有利于回收机制回收内存。

## 闭包的应用

1. 模仿块级作用域(等价于在for循环中使用let声明变量)(ES5中只有函数作用域和全局作用域，通过加上一层立即执行函数的方式，来为setTimeout代码块添加一层作用域)

```js
// 实现每隔一秒打印0  1  2  3
for (var index = 0; index < 3; index++) {
    (function (j) {
      setTimeout(() => {
        console.log(j)
      }, j * 1000)
    }(index))
}

// 闭包的经典问题
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function () {
            document.write(i +" ");
        }
    }
    return arr;
}
var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
// 输出结果：10 10 10 10 10 10 10 10 10 10 因为闭包的存在，使得数组arr[]中的十个函数共同操作一个父函数test中的变量i
}

// 解决方案，用一个立即执行函数来包含代码块(相当于给代码块新增了一块作用域,使用let声明变量的话可以得到相同的效果)
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
       (function(j){
            arr[j] = function () {
            document.write(j +" ");
        }
       }(i))
    }
    return arr;
}

var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
}
// 输出结果： 0 1 2 3 4 5 6 7 8 9
```

2. 私有变量(js中没有私有成员的概念，所有的属性都是共有的，但是私有变量的概念，任何在函数中定义的变量都可以认为是私有变量，因为在函数的外部不能访问这些变量，私有变量包括函数的参数，局部变量和函数内部定义的其它函数)

```js
function counterNum() {
    var num = 10; //私有变量
    this.add = function() {
      num++;
    }
    this.getNum = function () {
      return num ;
    }
  }

  const counterNum1 = new counterNum();
  let a = counterNum1.getNum(); //10
  counterNum1.add();
  let b = counterNum1.getNum(); //11
  console.log(counterNum1.num) //undefined(无法直接读取num变量，只能通过定义的方法来操作num变量)

```

3. 可以做缓存（存储结构） 相当于一个仓库(父函数返回多个子函数，这些子函数都会操作一个共同的变量)

```js
function father() {
    var num = 10;
    return {
      add: function() {
        num ++;
      },
      increase: function() {
        num --;
      },
      get:function() {
        return num;
      },
      set:function(Snum) {
        num = Snum
      }
    }
  }
  let a = father();
  a.add();
  a.add();
  a.get(); //12
  a.set(6);
  a.get();  //6
```

