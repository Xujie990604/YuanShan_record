<!--
 * @Author: x09898 coder_xujie@163.com
 * @Date: 2022-05-09 20:54:22
 * @LastEditors: xujie 1607526161@qq.com
 * @FilePath: \HTML-CSS-Javascript-\JAVAScript+ES6\JavaScript\JavaScript函数，作用域\闭包.md
 * @Description: 函数的闭包
-->
# 闭包

* 闭包: 当内部函数(内部函数使用了外部函数中的变量)被保存到外部时(1.使用 return 返回一个函数， 使用外部的变量接受函数。 2.使用构造函数 return 一个对象，对象的方法是个函数)，将会生成闭包，闭包会导致原有的作用域链不释放，造成内存泄漏(内存占用，剩的空间变少)。(内部函数拥有比它外部函数更长的生命周期)
* 被保存到外部的这个函数，自己预编译产生的执行上下文每次在执行自己时会重新创建一个新的，所以自己执行期上下文里面的变量不会受到上次调用的影响，但是自己父级的执行期上下文一直保留没有被释放，导致每次重复执行函数时，父级的变量会受上次调用的影响。
* 闭包会一直持有父函数的执行期上下文(活动对象)，导致占用内存不被清除，造成内存泄露。

## 闭包的应用

### 模仿块级作用域

```js
// 使用立即执行函数来 实现每隔一秒打印 0  1  2  3
for (var index = 0; index < 3; index++) {
    (function (j) {
      setTimeout(() => {
        console.log(j)
      }, j * 1000)
    }(index))
}
```

### 实现私有变量

* 在实现面向对象系统时使用闭包来模仿私有变量

```js
function counterNum() {
    var num = 10; //私有变量
    this.add = function() {
      num++;
    }
    this.getNum = function () {
      return num ;
    }
  }

  const counterNum1 = new counterNum();
  let a = counterNum1.getNum(); //10
  counterNum1.add();
  let b = counterNum1.getNum(); //11
  console.log(counterNum1.num) // undefined (无法直接读取 num 变量，只能通过定义的方法来操作 num 变量)

```

### 可以做缓存(存储结构)

* 相当于一个仓库(父函数返回多个子函数，这些子函数都会操作一个共同的变量)

```js
function father() {
    var num = 10;
    return {
      add: function() {
        num ++;
      },
      increase: function() {
        num --;
      },
      get:function() {
        return num;
      },
      set:function(Snum) {
        num = Snum
      }
    }
  }
  let a = father();
  a.add();
  a.add();
  a.get(); //12
  a.set(6);
  a.get();  //6
```

### 高阶函数(柯里化)

### 记忆函数

* 存储之前计算的结果，避免重复计算

```JS
    // 
    const fibonacci = function () {
      const list = [1, 1]
      const fb = function(n) {
        let result = list[n]
        if(result === undefined) {
          result=  fb(n - 1) + fb(n - 2)
          list[n] = result
        }
        return result
      }
      return fb
    }(); //!有一个执行符号
``

### 防抖节流

## 闭包带来的问题

* 解决内存泄漏问题:

1. 将保留内部函数的变量赋值为 null, 没有变量持有返回出来的内部函数后，内部函数占用的内存会被自动回收，内部函数持有的父函数执行期上下文也就会被回收
2. 在退出外部函数之前，将不使用的局部变量赋值为 null

```js
// ES6 之前使用立即执行函数来解决
// ES6 之后使用块级作用域来解决
// 因为闭包的存在，最后的输出结果会是 4 4 4 4
for(var i = 0; i < 4; i++) {
  etTimeout(() => {
  console.log(i)})
}

// 使用立即执行函数来 实现每隔一秒打印 0  1  2  3
for (var index = 0; index < 3; index++) {
    (function (j) {
      setTimeout(() => {
        console.log(j)
      }, j * 1000)
    }(index))
}

// 使用块级作用域来 实现每隔一秒打印 0  1  2  3
for(let i = 0; i < 4; i++) {
  setTimeout(() => {
  console.log(i)})
}
```
