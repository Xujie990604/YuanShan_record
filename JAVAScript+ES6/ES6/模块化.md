# 模块化

* 互相依赖的模块必须要有一个模块作为入口，这是代码执行的起点(但是在入口代码执行之前，需要递归的加载所依赖的模块，模块必须在依赖加载完之后才能执行)
* 解决变量命名冲突的问题
* 以前使用立即执行函数或者使用对象来解决这种问题，但是使用立即执行函数的话，函数外面的 JS 语句无法使用立即执行函数内的变量和方法。需要使用 return 来返回一个对象。(ES5的模块化)

## ES6的模块化（本地使用的话，需要把网页在服务器打开）

* 带有 type="module" 的 `<script>` 标签告诉浏览器相关代码需要按照模块的方式执行(必须使用导入导出才能使用其他模块的变量)
* 带有 type="module" 的 `<script>` 标签和带有 defer `<script>` 标签的行为一样。被立即下载，但是延迟到文档加载完再执行。
* 完全支持 ES6 的浏览器，会从顶层模块加载整个依赖图，并且是异步完成的。模块文件按需加载(没有被使用的话就不会被加载)

### 模块的导出

```js
// 不允许export定义在某个块中
if(true) {
    export ...
}

// export的位置与代码定义的位置无关
// export可以在变量定义之前，但是需要避免

// 导出单个变量
export const foo = "aaa"

let bar = "bbb";
export {
    bar
}

let name = "xujie"
export {
    name as id //使用别名的导出方式必须在{}中
}

// 默认导出
// 但是每个模块只能默认导出一个东西
// 并且导入的时候不能使用{}
// export default a = {}的形式是错的。使用default的意思就是，把default后面的变量赋值为default，应该直接export default {...}
export default name;
export { name as default } //和上面的语句是等价的

// 默认导出和一般的导出是相互独立的，可以同时定义默认导出和一般的导出
export { name, phone }
export default a;

export { name, phone, a as default } //等价于上面的两条语句
// 默认导出和一般的导出同时定义时的接收
import a, { name, phone } from './tool.js'
import { default as a, name, phone } from './tool.js'
```

### 模块的导入

* 加载一个模块的时候，即使没有公共的接口，也会执行模块体中的代码。

```js
// import语句不能声明在块级中
if(true) {
    import ...
}
// import语句会被提升到模块的顶部
// 可以但是要避免在import之前使用导入的变量
// 模块的路径只能是静态的，不能是动态计算的结果，不能使用变量。

// 默认的导入
// 这两种方式等价
import name from './tool.js'
import { name as default  } from './tool.js'

// 使用 import 导入的变量就像是 const 声明的一样
// 基本数据类型的值不能被修改
// 引用类型的值(例如对象)能够添加，删除，修改属性。但是不能够赋值为一个新对象
import { name, person } from './tool.js'
```
