# 模块化

* 互相依赖的模块必须要有一个模块作为入口，这是代码执行的起点(但是在入口代码执行之前，需要递归的加载所依赖的模块，模块必须在依赖加载完之后才能执行)
* 解决变量命名冲突的问题
* 以前使用立即执行函数或者使用对象来解决这种问题，但是使用立即执行函数的话，函数外面的 JS 语句无法使用立即执行函数内的变量和方法。需要使用 return 来返回一个对象。(ES5的模块化)

## ES6的模块化（本地使用的话，需要把网页在服务器打开）

* 带有 type="module" 的 `<script>` 标签告诉浏览器相关代码需要按照模块的方式执行(必须使用导入导出才能使用其他模块的变量)
* 带有 type="module" 的 `<script>` 标签和带有 defer `<script>` 标签的行为一样。被立即下载，但是延迟到文档加载完再执行。
* 完全支持 ES6 的浏览器，会从顶层模块加载整个依赖图，并且是异步完成的。模块文件按需加载(没有被使用的话就不会被加载)
* module 是在解析时(JS 代码还没有执行前就加载了，所以不能再判断条件中加载(不清楚当前 JS 的值是否为 true))加载的，并且是异步的
* module 进行导出是并不是直接导出一个对象的引用(和 commonJS 进行区分)。 a 模块中导入 b 模块时，b 模块中对于变量的修改会实时反映到 a 模块中(无论是基本数据类型还是引用数据类型)。但是在 a 模块中无法修改 b 导出的基本数据类型，只能修改引用数据类型的属性(相当于导出的变量被 const 修饰)

### 模块的导出

```js
// 不允许 export 定义在某个块中
if(true) {
    export ...
}

// export 的位置与代码定义的位置无关
// export 可以在变量定义之前，但是需要避免

// 导出单个变量
export const foo = "aaa"

let bar = "bbb";
// 这个 {} 并不是对象，和 commonJS 规范有差异
export {
    bar
}

let name = "xujie"
export {
    name as id // 使用别名的导出方式必须在 {} 中
}

// 默认导出
// 但是每个模块只能默认导出一个东西
// 并且导入的时候不能使用 {}
// export default a = {} 的形式是错的。使用 default 的意思就是，把 default 后面的变量赋值为 default，应该直接 export default {...}
export default name;
export { name as default } //和上面的语句是等价的

// 默认导出和一般的导出是相互独立的，可以同时定义默认导出和一般的导出
export { name, phone }
export default a;

export { name, phone, a as default } //等价于上面的两条语句
// 默认导出和一般的导出同时定义时的接收
import a, { name, phone } from './tool.js'
import { default as a, name, phone } from './tool.js'
```

### 模块的导入

* 加载一个模块的时候，即使没有公共的接口，也会执行模块体中的代码。

```js
// import语句不能声明在块级中
// 如果想要在块中导入模块的话可以使用 import() 函数进行导入，使用 Promise 来进行后续处理
if(true) {
    import ...
}
// import 语句会被提升到模块的顶部
// 可以但是要避免在 import 之前使用导入的变量
// 模块的路径只能是静态的，不能是动态计算的结果，不能使用变量。

// 默认的导入
// 这两种方式等价
import name from './tool.js'
import { name as default  } from './tool.js'

// 使用 import 导入的变量就像是 const 声明的一样
// 基本数据类型的值不能被修改
// 引用类型的值(例如对象)能够添加，删除，修改属性。但是不能够赋值为一个新对象
import { name, person } from './tool.js'
```
