# let const

## let

1. 只在命令所在的块级作用域有效
2. let 非常适合在for()循环中使用，变量只在本轮循环体内有效(每一次循环都是一个新的变量)，即不会有类似闭包行为的产生，又不会污染全局变量。
   * for(){}循环的特点，设置循环的那部分是一个父级作用域，循环体内部是一个单独的子作用域。(如果子作用域同样也声明了变量i，那么循环内的i使用子循环内定义的，和作用域链知识有关)
3. 不存在变量提升,在声明之前使用变量就会报错。
4. 暂时性死区
   * 只要块级作用域内有let和const命令，不会受到外部全局变量的影响。声明之前就使用会报错。
   * typeof()搭配let使用，声明之前使用因为死区会报错，反而不声明使用输出undefined,typeof()操作符不在是绝对不会报错的了。
5. 不允许重复说明,不允许在相同的作用域内，重复声明同一个变量。

## 块级作用域

1. es5只有 函数作用域  全局作用域
2. es6 块级作用域  有花括号就算 {} if(){} for(){} ES6的块级作用域是通过let和const标识符来实现的。
3. es5  if(){}里面不能有函数声明，每个浏览器的支持程度都不太一样。如果真的有需求。可以使用函数表达式
4. 块级作用域的出现使得立即执行函数不在十分必要，直接用一个{}来代替，立即执行函数

## 块级作用域和函数声明

1. ES5规定，函数只能在顶层作用域和函数作用域中声明。(不能再块级作用域中声明。但是浏览器没有遵循还在支持块级作用域中声明函数。)
2. ES6引入了块级作用域，块级作用域中声明的函数类似于let，(块级作用域之外不可使用。但是因为对于ES5的代码影响较大，不在ES6的环境中遵循)
3. 浏览器在ES6环境下遵循(除了ES6环境的不用遵循，当做let来看待)。
   * 允许在块级作用域中声明函数
   * 函数声明类似于var，会提升到全局作用域或函数作用域顶部。
   * 同时，函数声明还会提升到所在的块级作用域的顶部。
**因为不同环境的浏览器差异太大，所以避免在块级作用域中使用函数声明，用函数表达式来代替。**

## let必须声明在块级作用域的顶部

1. ES6的块级作用域必须有大括号，如果没有大括号，js引擎认为不存在块级作用域
2. 严格模式下，函数声明只能在当前作用域的顶层。

## const

1. const声明一个只读的常量，值不能改变，一旦声明必须赋值。
2. 只在块级作用域有效
3. 没有变量提升，有暂时性死区。
4. 不可重复声明

### const常量本质

* 本质是const执行的内存地址不改变，简单类型的值就是常量，复合类型的值保证指针是不变的。
* const声明的对象可以添加属性。不可以重新赋值新的对象。实质是不改变地址。对象的属性添加不更改地址。
* 想要对象冻结，使用Object.freeze()方法

## 顶层对象的属性

1. ES5之前，顶层对象的属性(window)和全局变量是等价的 (变量未声明就使用不报错)
2. ES6之后，var 和 function 声明的全局变量依旧是顶层对象(window窗口)的属性，let,const,class声明的全局变量不在属于顶层对象。

## globalThis对象

1. 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
2. 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
3. Node 里面，顶层对象是global，但其他环境都不支持。

**ES2020在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。**
