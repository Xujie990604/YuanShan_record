# 变量的解构赋值

## 数组的解构赋值

* 解构不成功，变量的值等于undefined
* 不完全解构
* let [foo] = 1|false|NaN|undefined|null|{};
    1. 会报错
    2. 等号的右边不是可以遍历的结构
    3. 转化为对象后不具备Iterator接口，或者本身不具备Iterator接口。
* 解构赋值允许默认值
    1. ES6内部使用严格相等运算符(===)，只有当一个数组的成员严格等于undefined时。默认值才会生效。
    2. 如果默认值是一个表达式，惰性求值，只有在用到的时候才会求值。

## 对象的解构赋值

* 数组解构是按照顺序来的，对象解构是按照同名属性。
* 解构失败的值为undefined
* let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
* 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
* let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
* 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
* 对象的解构赋值可以取到对象继承的属性。
* 将一个已经声明的变量用于解构赋值，需要将整个赋值语句放在一个圆括号里。

* 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```javascript
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3
```

## 字符串的解构赋值

* 字符串也可以解构赋值没因为字符串被转换成了一个类似数组的对象。类数组内还有length属性。

## 数值和布尔值的解构赋值

```javascript
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

* 解构赋值的规则时，只要等号的右边不是对象或者数组，就会先被转换为对象。
* null undefined 无法转为对象

## 函数参数的解构赋值

* 函数的参数可以使用解构赋值
* function move({x = 0, y = 0} = {}) {
  return [x, y];
}
* function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

## 圆括号问题

* 不能使用圆括号的情况
    1. 变量声明语句
    2. 函数参数
    3. 赋值语句的模式
* 可以使用圆括号的情况
    1. 赋值语句的非模式部分

## 用途

1. 交换变量
2. 从函数中返回多个值
3. 函数参数的定义
4. 提取JSON数据
5. 函数参数的默认值
6. 遍历Map结构
7. 输入模块的指定方法
